{"files":[{"path":["/","Users","ozan","Projects","unport","src","client.rs"],"content":"use anyhow::{Context, Result};\nuse std::env;\nuse std::os::unix::net::UnixStream;\nuse std::io::{BufRead, BufReader, Write};\nuse tracing::warn;\n\nuse crate::log_info;\n\nuse crate::config::Config;\nuse crate::detect::{detect, PortStrategy};\nuse crate::process::spawn_app;\nuse crate::types::{pid_path, socket_path, Request, Response};\n\n/// Send a request to the daemon and get a response\nfn send_request(request: &Request) -> Result<Response> {\n    let socket = socket_path();\n    let mut stream = UnixStream::connect(&socket).context(\n        \"Could not connect to daemon. Is it running? Start it with: unport daemon\",\n    )?;\n\n    let request_json = serde_json::to_string(request)? + \"\\n\";\n    stream.write_all(request_json.as_bytes())?;\n\n    let mut reader = BufReader::new(stream);\n    let mut line = String::new();\n    reader.read_line(&mut line)?;\n\n    // Handle empty response (e.g., daemon closed connection after shutdown)\n    if line.is_empty() {\n        return Ok(Response::Ok(None));\n    }\n\n    let response: Response = serde_json::from_str(&line)?;\n    Ok(response)\n}\n\n/// Start an app and register with daemon\npub async fn start() -> Result<()> {\n    let cwd = env::current_dir()?;\n\n    // Load config\n    let config = Config::load(&cwd)?;\n    let domain = config.full_domain();\n\n    // Detect framework\n    let detection = detect(&cwd)?;\n    log_info!(\"Detected framework: {}\", detection.framework);\n\n    // Get start command (from config or detection)\n    let start_command = config.start.as_deref().unwrap_or(&detection.start_command);\n\n    // Get port from daemon\n    let port = match send_request(&Request::GetPort)? {\n        Response::Port(p) => p,\n        Response::Error(e) => anyhow::bail!(\"{}\", e),\n        _ => anyhow::bail!(\"Unexpected response from daemon\"),\n    };\n\n    log_info!(\"Assigned port: {}\", port);\n\n    // Determine port strategy\n    let port_strategy = if config.port_arg.is_some() {\n        PortStrategy::CliFlag(config.port_arg.clone().unwrap())\n    } else if config.port_env.is_some() {\n        PortStrategy::EnvVar(config.port_env.clone().unwrap())\n    } else {\n        detection.port_strategy\n    };\n\n    // Check if HTTPS is enabled\n    let https_enabled = match send_request(&Request::HttpsStatus) {\n        Ok(Response::HttpsEnabled(enabled)) => enabled,\n        _ => false,\n    };\n\n    if https_enabled {\n        log_info!(\"HTTPS enabled, certificate updated for https://{}\", domain);\n    }\n\n    // Spawn the app\n    println!(\"Starting {}...\", config.domain);\n    println!(\"Running: {} (port {})\", start_command, port);\n    if https_enabled {\n        println!(\"Available at: http://{}\", domain);\n        println!(\"              https://{}\", domain);\n    } else {\n        println!(\"Available at: http://{}\", domain);\n    }\n    println!();\n\n    let mut child = spawn_app(\n        start_command,\n        port,\n        &port_strategy,\n        config.port_env.as_deref(),\n        config.port_arg.as_deref(),\n    )?;\n\n    let pid = child.id();\n\n    // Register with daemon\n    match send_request(&Request::Register {\n        domain: domain.clone(),\n        port,\n        pid,\n        directory: cwd,\n    })? {\n        Response::Ok(_) => {}\n        Response::Error(e) => {\n            warn!(\"Failed to register: {}\", e);\n        }\n        _ => {}\n    }\n\n    // Set up Ctrl+C handler\n    let domain_clone = domain.clone();\n    ctrlc::set_handler(move || {\n        // Unregister on exit\n        let _ = send_request(&Request::Unregister {\n            domain: domain_clone.clone(),\n        });\n        std::process::exit(0);\n    })?;\n\n    // Wait for child to exit\n    let status = child.wait()?;\n\n    // Unregister\n    let _ = send_request(&Request::Unregister { domain });\n\n    if status.success() {\n        Ok(())\n    } else {\n        anyhow::bail!(\"Process exited with status: {}\", status)\n    }\n}\n\n/// List all registered services\npub async fn list() -> Result<()> {\n    let response = send_request(&Request::List)?;\n\n    match response {\n        Response::Services(services) => {\n            if services.is_empty() {\n                println!(\"No services registered.\");\n            } else {\n                println!(\n                    \"{:<24} {:<8} {:<8} {}\",\n                    \"DOMAIN\", \"PORT\", \"PID\", \"DIRECTORY\"\n                );\n                for service in services {\n                    let status = if is_process_alive(service.pid) {\n                        \"\"\n                    } else {\n                        \" (dead)\"\n                    };\n                    println!(\n                        \"{:<24} {:<8} {:<8} {}{}\",\n                        service.domain,\n                        service.port,\n                        service.pid,\n                        service.directory.display(),\n                        status\n                    );\n                }\n            }\n        }\n        Response::Error(e) => {\n            anyhow::bail!(\"{}\", e);\n        }\n        _ => {\n            anyhow::bail!(\"Unexpected response\");\n        }\n    }\n\n    Ok(())\n}\n\n/// Stop a service by domain\npub async fn stop_service(domain: &str) -> Result<()> {\n    let full_domain = if domain.contains('.') {\n        domain.to_string()\n    } else {\n        format!(\"{}.localhost\", domain)\n    };\n\n    let response = send_request(&Request::Stop { domain: full_domain })?;\n\n    match response {\n        Response::Ok(msg) => {\n            println!(\"{}\", msg.unwrap_or_else(|| \"Stopped\".into()));\n        }\n        Response::Error(e) => {\n            anyhow::bail!(\"{}\", e);\n        }\n        _ => {\n            anyhow::bail!(\"Unexpected response\");\n        }\n    }\n\n    Ok(())\n}\n\n/// Stop the daemon\npub async fn stop_daemon() -> Result<()> {\n    let response = send_request(&Request::Shutdown)?;\n\n    match response {\n        Response::Ok(_) => {\n            println!(\"Daemon stopped.\");\n        }\n        Response::Error(e) => {\n            anyhow::bail!(\"{}\", e);\n        }\n        _ => {}\n    }\n\n    Ok(())\n}\n\n/// Show daemon status\npub async fn daemon_status() -> Result<()> {\n    let pid_file = pid_path();\n\n    // Check if PID file exists\n    if !pid_file.exists() {\n        println!(\"Status: stopped\");\n        println!(\"  Daemon is not running (no PID file)\");\n        return Ok(());\n    }\n\n    // Read PID\n    let pid_str = std::fs::read_to_string(&pid_file)?;\n    let pid: u32 = pid_str.trim().parse().context(\"Invalid PID file\")?;\n\n    // Check if process is alive\n    if !is_process_alive(pid) {\n        println!(\"Status: stopped\");\n        println!(\"  Daemon is not running (stale PID file, process {} not found)\", pid);\n        return Ok(());\n    }\n\n    // Try to connect to daemon\n    let service_count = match send_request(&Request::List) {\n        Ok(Response::Services(services)) => services.len(),\n        Ok(_) => 0,\n        Err(_) => {\n            println!(\"Status: error\");\n            println!(\"  Process {} is running but daemon is not responding\", pid);\n            return Ok(());\n        }\n    };\n\n    // Get uptime from PID file modification time\n    let uptime = if let Ok(metadata) = std::fs::metadata(&pid_file) {\n        if let Ok(created) = metadata.modified() {\n            if let Ok(duration) = created.elapsed() {\n                format_duration(duration)\n            } else {\n                \"unknown\".to_string()\n            }\n        } else {\n            \"unknown\".to_string()\n        }\n    } else {\n        \"unknown\".to_string()\n    };\n\n    println!(\"Status: running\");\n    println!(\"  PID:      {}\", pid);\n    println!(\"  Uptime:   {}\", uptime);\n    println!(\"  Services: {}\", service_count);\n\n    Ok(())\n}\n\nfn format_duration(duration: std::time::Duration) -> String {\n    let secs = duration.as_secs();\n    if secs < 60 {\n        format!(\"{}s\", secs)\n    } else if secs < 3600 {\n        format!(\"{}m {}s\", secs / 60, secs % 60)\n    } else if secs < 86400 {\n        format!(\"{}h {}m\", secs / 3600, (secs % 3600) / 60)\n    } else {\n        format!(\"{}d {}h\", secs / 86400, (secs % 86400) / 3600)\n    }\n}\n\nfn is_process_alive(pid: u32) -> bool {\n    let result = unsafe { libc::kill(pid as i32, 0) };\n    if result == 0 {\n        return true;\n    }\n    // EPERM means process exists but we can't signal it (e.g., root-owned process)\n    let errno = std::io::Error::last_os_error().raw_os_error().unwrap_or(0);\n    errno == libc::EPERM\n}\n\n/// Add or remove the CA certificate from the system trust store\npub async fn trust_ca(remove: bool) -> Result<()> {\n    crate::tls::trust_ca(remove)\n}\n\n/// Regenerate TLS certificate with SANs for all registered domains\npub async fn regen_cert() -> Result<()> {\n    use crate::types::Response;\n\n    // Get list of registered services from daemon\n    let domains: Vec<String> = match send_request(&crate::types::Request::List) {\n        Ok(Response::Services(services)) => {\n            services.into_iter().map(|s| s.domain).collect()\n        }\n        Ok(_) => vec![],\n        Err(_) => {\n            println!(\"Note: Daemon not running, generating cert for localhost only.\");\n            vec![]\n        }\n    };\n\n    // Generate new certificate with all domains\n    crate::tls::generate_cert(&domains)?;\n\n    println!(\"\\n⚠️  Restart the daemon to use the new certificate:\");\n    println!(\"   sudo unport daemon stop && sudo unport daemon start -d --https\");\n\n    Ok(())\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":164},{"path":["/","Users","ozan","Projects","unport","src","config.rs"],"content":"use anyhow::{Context, Result};\nuse serde::Deserialize;\nuse std::path::Path;\n\n/// Configuration from unport.json\n#[derive(Debug, Deserialize)]\npub struct Config {\n    /// Domain name (e.g., \"api\" becomes \"api.localhost\")\n    pub domain: String,\n\n    /// Optional: Custom start command\n    pub start: Option<String>,\n\n    /// Optional: Environment variable name for port (default: PORT)\n    #[serde(rename = \"portEnv\")]\n    pub port_env: Option<String>,\n\n    /// Optional: CLI argument for port (e.g., \"--port\")\n    #[serde(rename = \"portArg\")]\n    pub port_arg: Option<String>,\n}\n\nimpl Config {\n    /// Load config from unport.json in the given directory\n    pub fn load(dir: &Path) -> Result<Self> {\n        let config_path = dir.join(\"unport.json\");\n\n        let content = std::fs::read_to_string(&config_path)\n            .with_context(|| format!(\"Could not read {}\", config_path.display()))?;\n\n        let config: Config = serde_json::from_str(&content)\n            .with_context(|| format!(\"Invalid JSON in {}\", config_path.display()))?;\n\n        Ok(config)\n    }\n\n    /// Get the full domain (e.g., \"api.localhost\")\n    pub fn full_domain(&self) -> String {\n        format!(\"{}.localhost\", self.domain)\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","ozan","Projects","unport","src","daemon.rs"],"content":"use anyhow::{Context, Result};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::net::UnixListener;\nuse tokio::sync::RwLock;\nuse tracing::error;\n\nuse crate::log_info;\n\nuse crate::proxy;\nuse crate::tls;\nuse crate::types::{\n    pid_path, registry_path, socket_path, unport_dir, Request as DaemonRequest,\n    Response as DaemonResponse, Service, PORT_RANGE_END, PORT_RANGE_START,\n};\n\n/// Registry of services\n#[derive(Default)]\npub struct Registry {\n    services: HashMap<String, Service>,\n    next_port: u16,\n}\n\nimpl Registry {\n    pub fn new() -> Self {\n        Self {\n            services: HashMap::new(),\n            next_port: PORT_RANGE_START,\n        }\n    }\n\n    /// Load registry from disk\n    pub fn load() -> Self {\n        let path = registry_path();\n        if path.exists() {\n            if let Ok(content) = std::fs::read_to_string(&path) {\n                if let Ok(services) = serde_json::from_str::<HashMap<String, Service>>(&content) {\n                    let max_port = services\n                        .values()\n                        .map(|s| s.port)\n                        .max()\n                        .unwrap_or(PORT_RANGE_START - 1);\n                    return Self {\n                        services,\n                        next_port: max_port + 1,\n                    };\n                }\n            }\n        }\n        Self::new()\n    }\n\n    /// Save registry to disk\n    pub fn save(&self) -> Result<()> {\n        let path = registry_path();\n        let content = serde_json::to_string_pretty(&self.services)?;\n        std::fs::write(&path, content)?;\n        Ok(())\n    }\n\n    /// Get next available port (checks if port is actually free)\n    pub fn get_port(&mut self) -> u16 {\n        let start = self.next_port;\n        loop {\n            let port = self.next_port;\n            self.next_port += 1;\n            if self.next_port > PORT_RANGE_END {\n                self.next_port = PORT_RANGE_START;\n            }\n\n            // Check if port is actually available by trying to bind\n            if is_port_available(port) {\n                return port;\n            }\n\n            // Prevent infinite loop if all ports are taken\n            if self.next_port == start {\n                // Fall back to returning the port anyway; it will fail at app startup\n                return port;\n            }\n        }\n    }\n\n    /// Register a service\n    pub fn register(&mut self, service: Service) {\n        self.services.insert(service.domain.clone(), service);\n        let _ = self.save();\n    }\n\n    /// Unregister a service\n    pub fn unregister(&mut self, domain: &str) -> Option<Service> {\n        let service = self.services.remove(domain);\n        let _ = self.save();\n        service\n    }\n\n    /// Get a service by domain\n    pub fn get(&self, domain: &str) -> Option<&Service> {\n        self.services.get(domain)\n    }\n\n    /// List all services\n    pub fn list(&self) -> Vec<Service> {\n        self.services.values().cloned().collect()\n    }\n\n    /// Clean up dead processes\n    pub fn cleanup_dead(&mut self) {\n        let dead: Vec<String> = self\n            .services\n            .iter()\n            .filter(|(_, s)| !is_process_alive(s.pid))\n            .map(|(domain, _)| domain.clone())\n            .collect();\n\n        for domain in dead {\n            log_info!(\"Cleaning up dead service: {}\", domain);\n            self.services.remove(&domain);\n        }\n        let _ = self.save();\n    }\n}\n\nfn is_process_alive(pid: u32) -> bool {\n    unsafe { libc::kill(pid as i32, 0) == 0 }\n}\n\n/// Check if a port is available by attempting to bind to it\nfn is_port_available(port: u16) -> bool {\n    // Check both IPv4 and IPv6 since apps may bind to either\n    std::net::TcpListener::bind((\"127.0.0.1\", port)).is_ok()\n        && std::net::TcpListener::bind((\"::1\", port)).is_ok()\n        && std::net::TcpListener::bind((\"0.0.0.0\", port)).is_ok()\n}\n\ntype SharedRegistry = Arc<RwLock<Registry>>;\n\n/// Run the daemon\npub async fn run(detach: bool, https: bool) -> Result<()> {\n    // If detach requested, spawn daemon in background and exit\n    if detach {\n        let exe = std::env::current_exe().context(\"Failed to get current executable\")?;\n\n        // Ensure unport directory exists\n        let dir = unport_dir();\n        std::fs::create_dir_all(&dir).context(\"Failed to create ~/.unport directory\")?;\n\n        // Open log file for daemon output\n        let log_path = dir.join(\"daemon.log\");\n        let log_file = std::fs::File::create(&log_path)\n            .context(\"Failed to create daemon log file\")?;\n        let log_file_err = log_file.try_clone()?;\n\n        let mut args = vec![\"daemon\", \"start\"];\n        if https {\n            args.push(\"--https\");\n        }\n\n        std::process::Command::new(exe)\n            .args(&args)\n            .stdin(std::process::Stdio::null())\n            .stdout(log_file)\n            .stderr(log_file_err)\n            .spawn()\n            .context(\"Failed to spawn daemon process\")?;\n\n        println!(\"Daemon started in background. Logs at: {:?}\", log_path);\n        return Ok(());\n    }\n\n    // Ensure unport directory exists\n    let dir = unport_dir();\n    std::fs::create_dir_all(&dir).context(\"Failed to create ~/.unport directory\")?;\n\n    // Check if daemon is already running\n    let pid_file = pid_path();\n    if pid_file.exists() {\n        let pid_str = std::fs::read_to_string(&pid_file)?;\n        if let Ok(pid) = pid_str.trim().parse::<u32>() {\n            if is_process_alive(pid) {\n                anyhow::bail!(\"Daemon already running (PID {})\", pid);\n            }\n        }\n        std::fs::remove_file(&pid_file)?;\n    }\n\n    // Write PID file\n    std::fs::write(&pid_file, std::process::id().to_string())?;\n\n    // Remove old socket if exists\n    let sock_path = socket_path();\n    if sock_path.exists() {\n        std::fs::remove_file(&sock_path)?;\n    }\n\n    // Load registry and cleanup dead processes\n    let registry = Arc::new(RwLock::new(Registry::load()));\n    {\n        let mut reg = registry.write().await;\n        reg.cleanup_dead();\n    }\n\n    log_info!(\"Starting daemon...\");\n\n    // Initialize TLS if HTTPS is enabled\n    let tls_acceptor: Option<proxy::SharedTlsAcceptor> = if https {\n        match tls::init_tls() {\n            Ok(acceptor) => {\n                println!(\"\\n⚠️  To trust HTTPS in browsers, run: sudo unport trust-ca\\n\");\n                Some(Arc::new(RwLock::new(acceptor)))\n            }\n            Err(e) => {\n                error!(\"Failed to initialize TLS: {}\", e);\n                return Err(e);\n            }\n        }\n    } else {\n        None\n    };\n\n    // Start Unix socket listener for CLI commands\n    let socket_registry = registry.clone();\n    let socket_tls = tls_acceptor.clone();\n    let socket_handle = tokio::spawn(async move {\n        if let Err(e) = run_socket_server(socket_registry, socket_tls).await {\n            error!(\"Socket server error: {}\", e);\n        }\n    });\n\n    // Start HTTP proxy\n    let proxy_registry = registry.clone();\n    let proxy_handle = tokio::spawn(async move {\n        if let Err(e) = proxy::run_http(proxy_registry).await {\n            error!(\"HTTP proxy server error: {}\", e);\n        }\n    });\n\n    // Start HTTPS proxy if enabled\n    let https_handle = if let Some(acceptor) = tls_acceptor {\n        let https_registry = registry.clone();\n        Some(tokio::spawn(async move {\n            if let Err(e) = proxy::run_https(https_registry, acceptor).await {\n                error!(\"HTTPS proxy server error: {}\", e);\n            }\n        }))\n    } else {\n        None\n    };\n\n    // Start periodic cleanup of dead processes\n    let cleanup_registry = registry.clone();\n    tokio::spawn(async move {\n        loop {\n            tokio::time::sleep(Duration::from_secs(30)).await;\n            let mut reg = cleanup_registry.write().await;\n            reg.cleanup_dead();\n        }\n    });\n\n    if https {\n        log_info!(\"Daemon running. HTTP on :80, HTTPS on :443, socket at {:?}\", sock_path);\n    } else {\n        log_info!(\"Daemon running. HTTP on :80, socket at {:?}\", sock_path);\n    }\n\n    // Wait for shutdown\n    tokio::select! {\n        _ = socket_handle => {},\n        _ = proxy_handle => {},\n        _ = async {\n            if let Some(h) = https_handle {\n                h.await.ok();\n            } else {\n                std::future::pending::<()>().await;\n            }\n        } => {},\n        _ = tokio::signal::ctrl_c() => {\n            log_info!(\"Shutting down...\");\n        }\n    }\n\n    // Cleanup\n    let _ = std::fs::remove_file(&sock_path);\n    let _ = std::fs::remove_file(&pid_file);\n\n    Ok(())\n}\n\n/// Run the Unix socket server for CLI commands\nasync fn run_socket_server(\n    registry: SharedRegistry,\n    tls_acceptor: Option<proxy::SharedTlsAcceptor>,\n) -> Result<()> {\n    let sock = socket_path();\n    let listener = UnixListener::bind(&sock)?;\n\n    // Make socket world-writable so non-root users can connect\n    // when daemon runs as root\n    use std::os::unix::fs::PermissionsExt;\n    std::fs::set_permissions(&sock, std::fs::Permissions::from_mode(0o777))?;\n\n    loop {\n        let (stream, _) = listener.accept().await?;\n        let registry = registry.clone();\n        let tls = tls_acceptor.clone();\n\n        tokio::spawn(async move {\n            if let Err(e) = handle_socket_client(stream, registry, tls).await {\n                error!(\"Client error: {}\", e);\n            }\n        });\n    }\n}\n\nasync fn handle_socket_client(\n    stream: tokio::net::UnixStream,\n    registry: SharedRegistry,\n    tls_acceptor: Option<proxy::SharedTlsAcceptor>,\n) -> Result<()> {\n    let (reader, mut writer) = stream.into_split();\n    let mut reader = BufReader::new(reader);\n    let mut line = String::new();\n\n    while reader.read_line(&mut line).await? > 0 {\n        let request: DaemonRequest = serde_json::from_str(&line)?;\n        let response = handle_request(request, &registry, &tls_acceptor).await;\n        let response_json = serde_json::to_string(&response)? + \"\\n\";\n        writer.write_all(response_json.as_bytes()).await?;\n        line.clear();\n    }\n\n    Ok(())\n}\n\nasync fn handle_request(\n    request: DaemonRequest,\n    registry: &SharedRegistry,\n    tls_acceptor: &Option<proxy::SharedTlsAcceptor>,\n) -> DaemonResponse {\n    match request {\n        DaemonRequest::Register {\n            domain,\n            port,\n            pid,\n            directory,\n        } => {\n            let mut reg = registry.write().await;\n            if reg.get(&domain).is_some() {\n                return DaemonResponse::Error(format!(\"Domain '{}' already registered\", domain));\n            }\n            reg.register(Service {\n                domain: domain.clone(),\n                port,\n                pid,\n                directory,\n            });\n            log_info!(\"Registered: {} -> localhost:{}\", domain, port);\n\n            // If HTTPS is enabled, regenerate certificate with new domain\n            if let Some(acceptor) = tls_acceptor {\n                let domains: Vec<String> = reg.list().into_iter().map(|s| s.domain).collect();\n                if let Err(e) = regenerate_tls_cert(&domains, acceptor).await {\n                    error!(\"Failed to regenerate TLS cert: {}\", e);\n                }\n            }\n\n            DaemonResponse::Ok(Some(format!(\"Registered {}\", domain)))\n        }\n        DaemonRequest::Unregister { domain } => {\n            let mut reg = registry.write().await;\n            if reg.unregister(&domain).is_some() {\n                log_info!(\"Unregistered: {}\", domain);\n                DaemonResponse::Ok(Some(format!(\"Unregistered {}\", domain)))\n            } else {\n                DaemonResponse::Error(format!(\"Domain '{}' not found\", domain))\n            }\n        }\n        DaemonRequest::GetPort => {\n            let mut reg = registry.write().await;\n            let port = reg.get_port();\n            DaemonResponse::Port(port)\n        }\n        DaemonRequest::List => {\n            let reg = registry.read().await;\n            DaemonResponse::Services(reg.list())\n        }\n        DaemonRequest::Stop { domain } => {\n            let mut reg = registry.write().await;\n            if let Some(service) = reg.unregister(&domain) {\n                // Send SIGTERM to the process\n                unsafe {\n                    libc::kill(service.pid as i32, libc::SIGTERM);\n                }\n                log_info!(\"Stopped: {}\", domain);\n                DaemonResponse::Ok(Some(format!(\"Stopped {}\", domain)))\n            } else {\n                DaemonResponse::Error(format!(\"Domain '{}' not found\", domain))\n            }\n        }\n        DaemonRequest::Shutdown => {\n            log_info!(\"Shutdown requested\");\n            std::process::exit(0);\n        }\n        DaemonRequest::HttpsStatus => {\n            DaemonResponse::HttpsEnabled(tls_acceptor.is_some())\n        }\n    }\n}\n\n/// Regenerate TLS certificate with new domains and hot-reload it\nasync fn regenerate_tls_cert(\n    domains: &[String],\n    acceptor: &proxy::SharedTlsAcceptor,\n) -> Result<()> {\n    // Generate new certificate\n    tls::generate_cert(domains)?;\n\n    // Load new TLS config\n    let new_acceptor = tls::load_tls_config()?;\n\n    // Hot-swap the acceptor\n    let mut guard = acceptor.write().await;\n    *guard = new_acceptor;\n\n    log_info!(\"TLS certificate regenerated with {} domains\", domains.len());\n    Ok(())\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":204},{"path":["/","Users","ozan","Projects","unport","src","detect.rs"],"content":"use anyhow::Result;\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::path::Path;\n\n/// Detected framework and how to inject port\n#[derive(Debug)]\npub struct Detection {\n    pub framework: String,\n    pub start_command: String,\n    pub port_strategy: PortStrategy,\n}\n\n#[derive(Debug)]\npub enum PortStrategy {\n    /// Set PORT environment variable\n    EnvVar(String),\n    /// Append --port flag to command\n    CliFlag(String),\n}\n\n#[derive(Deserialize)]\nstruct PackageJson {\n    scripts: Option<HashMap<String, String>>,\n    dependencies: Option<HashMap<String, serde_json::Value>>,\n    #[serde(rename = \"devDependencies\")]\n    dev_dependencies: Option<HashMap<String, serde_json::Value>>,\n}\n\n/// Detect framework from project directory\npub fn detect(dir: &Path) -> Result<Detection> {\n    // Check for package.json (Node.js projects)\n    let package_json_path = dir.join(\"package.json\");\n    if package_json_path.exists() {\n        let content = std::fs::read_to_string(&package_json_path)?;\n        let package: PackageJson = serde_json::from_str(&content)?;\n\n        let all_deps = merge_deps(&package.dependencies, &package.dev_dependencies);\n        let scripts = package.scripts.unwrap_or_default();\n        let dev_script = scripts.get(\"dev\").cloned().unwrap_or_default();\n\n        // Check for specific frameworks\n        if all_deps.contains_key(\"next\") {\n            return Ok(Detection {\n                framework: \"Next.js\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"vite\") || dev_script.contains(\"vite\") {\n            return Ok(Detection {\n                framework: \"Vite\".into(),\n                start_command: \"npm run dev --\".into(),\n                port_strategy: PortStrategy::CliFlag(\"--port\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"react-scripts\") {\n            return Ok(Detection {\n                framework: \"Create React App\".into(),\n                start_command: \"npm start\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"@remix-run/dev\") {\n            return Ok(Detection {\n                framework: \"Remix\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"nuxt\") {\n            return Ok(Detection {\n                framework: \"Nuxt\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"@nestjs/core\") {\n            return Ok(Detection {\n                framework: \"NestJS\".into(),\n                start_command: \"npm run start:dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"fastify\") {\n            return Ok(Detection {\n                framework: \"Fastify\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"express\") {\n            return Ok(Detection {\n                framework: \"Express\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        // Generic Node.js project\n        let start_cmd = if scripts.contains_key(\"dev\") {\n            \"npm run dev\"\n        } else if scripts.contains_key(\"start\") {\n            \"npm start\"\n        } else {\n            \"npm run dev\"\n        };\n\n        return Ok(Detection {\n            framework: \"Node.js\".into(),\n            start_command: start_cmd.into(),\n            port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n        });\n    }\n\n    // Check for Rails (Gemfile)\n    if dir.join(\"Gemfile\").exists() {\n        return Ok(Detection {\n            framework: \"Rails\".into(),\n            start_command: \"rails server\".into(),\n            port_strategy: PortStrategy::CliFlag(\"-p\".into()),\n        });\n    }\n\n    // Check for Django (manage.py)\n    if dir.join(\"manage.py\").exists() {\n        return Ok(Detection {\n            framework: \"Django\".into(),\n            start_command: \"python manage.py runserver\".into(),\n            port_strategy: PortStrategy::CliFlag(\"0.0.0.0:\".into()), // Special case: appends port directly\n        });\n    }\n\n    // Check for Go\n    if dir.join(\"go.mod\").exists() {\n        return Ok(Detection {\n            framework: \"Go\".into(),\n            start_command: \"go run .\".into(),\n            port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n        });\n    }\n\n    // Default fallback\n    Ok(Detection {\n        framework: \"Unknown\".into(),\n        start_command: \"npm run dev\".into(),\n        port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n    })\n}\n\nfn merge_deps(\n    deps: &Option<HashMap<String, serde_json::Value>>,\n    dev_deps: &Option<HashMap<String, serde_json::Value>>,\n) -> HashMap<String, serde_json::Value> {\n    let mut all = HashMap::new();\n    if let Some(d) = deps {\n        all.extend(d.clone());\n    }\n    if let Some(d) = dev_deps {\n        all.extend(d.clone());\n    }\n    all\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":83},{"path":["/","Users","ozan","Projects","unport","src","logger.rs"],"content":"//! Centralized logging module for unport\n//!\n//! Provides consistent log formatting with the [unport] prefix.\n//! All logs should use these macros instead of tracing directly.\n\n/// Log an info message with [unport] prefix\n#[macro_export]\nmacro_rules! log_info {\n    ($($arg:tt)*) => {\n        tracing::info!(\"[unport] {}\", format!($($arg)*))\n    };\n}\n\n/// Log a warning message with [unport] prefix\n#[macro_export]\nmacro_rules! log_warn {\n    ($($arg:tt)*) => {\n        tracing::warn!(\"[unport] {}\", format!($($arg)*))\n    };\n}\n\n/// Log an error message with [unport] prefix\n#[macro_export]\nmacro_rules! log_error {\n    ($($arg:tt)*) => {\n        tracing::error!(\"[unport] {}\", format!($($arg)*))\n    };\n}\n\n/// Log a debug message with [unport] prefix\n#[macro_export]\nmacro_rules! log_debug {\n    ($($arg:tt)*) => {\n        tracing::debug!(\"[unport] {}\", format!($($arg)*))\n    };\n}\n\n/// Log a trace message with [unport] prefix\n#[macro_export]\nmacro_rules! log_trace {\n    ($($arg:tt)*) => {\n        tracing::trace!(\"[unport] {}\", format!($($arg)*))\n    };\n}\n\n/// Initialize the tracing subscriber with default settings\npub fn init() {\n    use tracing_subscriber::EnvFilter;\n\n    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n\n    tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_target(false)\n        .init();\n}\n\n#[cfg(test)]\nmod tests {\n    /// Test that log macros format messages correctly with prefix\n    #[test]\n    fn test_log_info_format() {\n        // The macro expands to: tracing::info!(\"[unport] {}\", format!(...))\n        // We test the format string construction\n        let message = format!(\"Test message: {}\", 42);\n        let formatted = format!(\"[unport] {}\", message);\n        assert!(formatted.starts_with(\"[unport] \"));\n        assert!(formatted.contains(\"Test message: 42\"));\n    }\n\n    #[test]\n    fn test_log_format_with_multiple_args() {\n        let formatted = format!(\"[unport] {}\", format!(\"Port {} assigned to {}\", 4000, \"api.localhost\"));\n        assert_eq!(formatted, \"[unport] Port 4000 assigned to api.localhost\");\n    }\n\n    #[test]\n    fn test_log_format_with_debug_type() {\n        let path = std::path::PathBuf::from(\"/home/user/.unport\");\n        let formatted = format!(\"[unport] {}\", format!(\"Path: {:?}\", path));\n        assert!(formatted.contains(\"[unport]\"));\n        assert!(formatted.contains(\".unport\"));\n    }\n\n    #[test]\n    fn test_log_format_empty_message() {\n        let formatted = format!(\"[unport] {}\", \"\");\n        assert_eq!(formatted, \"[unport] \");\n    }\n\n    #[test]\n    fn test_log_format_special_characters() {\n        let formatted = format!(\"[unport] {}\", format!(\"URL: https://api.localhost:443/path?q=1&b=2\"));\n        assert!(formatted.contains(\"https://\"));\n        assert!(formatted.contains(\"?q=1&b=2\"));\n    }\n\n    #[test]\n    fn test_log_format_unicode() {\n        let formatted = format!(\"[unport] {}\", \"日本語テスト\");\n        assert!(formatted.contains(\"日本語テスト\"));\n    }\n\n    #[test]\n    fn test_log_format_newlines_preserved() {\n        let formatted = format!(\"[unport] {}\", \"Line 1\\nLine 2\");\n        assert!(formatted.contains(\"\\n\"));\n    }\n\n    #[test]\n    fn test_log_format_with_error() {\n        let error = std::io::Error::new(std::io::ErrorKind::NotFound, \"File not found\");\n        let formatted = format!(\"[unport] {}\", format!(\"Error: {}\", error));\n        assert!(formatted.contains(\"[unport]\"));\n        assert!(formatted.contains(\"File not found\"));\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":16}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","Users","ozan","Projects","unport","src","main.rs"],"content":"mod client;\nmod config;\nmod daemon;\nmod detect;\nmod logger;\nmod process;\nmod proxy;\nmod tls;\nmod types;\n\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"unport\")]\n#[command(about = \"Local development port manager with automatic domain routing\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Manage the unport daemon\n    Daemon {\n        #[command(subcommand)]\n        action: DaemonAction,\n    },\n    /// Start the app in current directory and register with daemon\n    Start,\n    /// Stop a running service by domain\n    Stop {\n        /// Domain name to stop\n        domain: String,\n    },\n    /// List all registered services\n    List,\n    /// Add unport CA to system trust store for HTTPS support\n    TrustCa {\n        /// Remove CA from trust store instead of adding\n        #[arg(long)]\n        remove: bool,\n    },\n    /// Delete generated TLS certificates (forces regeneration on next daemon start)\n    CleanCerts,\n    /// Regenerate TLS certificate with SANs for all registered domains\n    RegenCert,\n}\n\n#[derive(Subcommand)]\nenum DaemonAction {\n    /// Start the daemon\n    Start {\n        /// Run daemon in background (detached)\n        #[arg(short = 'd', long = \"detach\")]\n        detach: bool,\n        /// Enable HTTPS on port 443\n        #[arg(long)]\n        https: bool,\n    },\n    /// Stop the daemon\n    Stop,\n    /// Show daemon status\n    Status,\n}\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    logger::init();\n\n    let cli = Cli::parse();\n\n    match cli.command {\n        Commands::Daemon { action } => match action {\n            DaemonAction::Start { detach, https } => daemon::run(detach, https).await,\n            DaemonAction::Stop => client::stop_daemon().await,\n            DaemonAction::Status => client::daemon_status().await,\n        },\n        Commands::Start => client::start().await,\n        Commands::Stop { domain } => client::stop_service(&domain).await,\n        Commands::List => client::list().await,\n        Commands::TrustCa { remove } => client::trust_ca(remove).await,\n        Commands::CleanCerts => tls::clean_certs(),\n        Commands::RegenCert => client::regen_cert().await,\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}}],"covered":14,"coverable":14},{"path":["/","Users","ozan","Projects","unport","src","process.rs"],"content":"use anyhow::{Context, Result};\nuse std::process::{Child, Command, Stdio};\n\nuse crate::detect::PortStrategy;\n\n/// Spawn an app process with port injection\npub fn spawn_app(\n    command: &str,\n    port: u16,\n    port_strategy: &PortStrategy,\n    port_env_override: Option<&str>,\n    port_arg_override: Option<&str>,\n) -> Result<Child> {\n    let mut parts: Vec<&str> = command.split_whitespace().collect();\n    if parts.is_empty() {\n        anyhow::bail!(\"Empty command\");\n    }\n\n    let program = parts.remove(0);\n    let mut cmd = Command::new(program);\n    cmd.args(&parts);\n    cmd.stdin(Stdio::null());\n    cmd.stdout(Stdio::inherit());\n    cmd.stderr(Stdio::inherit());\n\n    // Apply port injection based on strategy\n    match (port_env_override, port_arg_override) {\n        // User override: env var\n        (Some(env_var), _) => {\n            cmd.env(env_var, port.to_string());\n        }\n        // User override: CLI arg\n        (_, Some(arg)) => {\n            cmd.arg(arg);\n            cmd.arg(port.to_string());\n        }\n        // Auto-detected strategy\n        _ => match port_strategy {\n            PortStrategy::EnvVar(var) => {\n                cmd.env(var, port.to_string());\n            }\n            PortStrategy::CliFlag(flag) => {\n                // Special case for Django: \"0.0.0.0:\" needs port appended directly\n                if flag.ends_with(':') {\n                    cmd.arg(format!(\"{}{}\", flag, port));\n                } else {\n                    cmd.arg(flag);\n                    cmd.arg(port.to_string());\n                }\n            }\n        },\n    }\n\n    let child = cmd.spawn().context(\"Failed to spawn process\")?;\n    Ok(child)\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","ozan","Projects","unport","src","proxy.rs"],"content":"use anyhow::{Context, Result};\nuse http_body_util::{BodyExt, Full};\nuse hyper::body::Bytes;\nuse hyper::server::conn::http1;\nuse hyper::service::service_fn;\nuse hyper::{body::Incoming, Request, Response};\nuse hyper_util::rt::TokioIo;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};\nuse tokio::net::{TcpListener, TcpStream};\nuse tokio::sync::RwLock;\nuse tokio_rustls::TlsAcceptor;\nuse tracing::{error, warn};\n\nuse crate::log_info;\n\nuse crate::daemon::Registry;\nuse crate::types::Service;\n\npub type SharedRegistry = Arc<RwLock<Registry>>;\npub type SharedTlsAcceptor = Arc<RwLock<TlsAcceptor>>;\n\n/// Run the HTTP proxy server on port 80\npub async fn run_http(registry: SharedRegistry) -> Result<()> {\n    let addr = SocketAddr::from(([127, 0, 0, 1], 80));\n    let listener = TcpListener::bind(addr).await.context(\n        \"Failed to bind to port 80. Try running with sudo or check if another process is using it.\",\n    )?;\n\n    log_info!(\"HTTP proxy listening on http://127.0.0.1:80\");\n\n    loop {\n        let (stream, _) = listener.accept().await?;\n        let registry = registry.clone();\n\n        tokio::spawn(async move {\n            if let Err(e) = handle_connection(stream, registry).await {\n                error!(\"HTTP connection error: {}\", e);\n            }\n        });\n    }\n}\n\n/// Run the HTTPS proxy server on port 443\npub async fn run_https(registry: SharedRegistry, acceptor: SharedTlsAcceptor) -> Result<()> {\n    let addr = SocketAddr::from(([127, 0, 0, 1], 443));\n    let listener = TcpListener::bind(addr).await.context(\n        \"Failed to bind to port 443. Try running with sudo or check if another process is using it.\",\n    )?;\n\n    log_info!(\"HTTPS proxy listening on https://127.0.0.1:443\");\n\n    loop {\n        let (stream, _) = listener.accept().await?;\n        let acceptor = acceptor.clone();\n        let registry = registry.clone();\n\n        tokio::spawn(async move {\n            // Get the current acceptor (allows hot-reload)\n            let tls_acceptor = acceptor.read().await.clone();\n            match tls_acceptor.accept(stream).await {\n                Ok(tls_stream) => {\n                    if let Err(e) = handle_tls_connection(tls_stream, registry).await {\n                        error!(\"HTTPS connection error: {}\", e);\n                    }\n                }\n                Err(e) => {\n                    error!(\"TLS handshake error: {}\", e);\n                }\n            }\n        });\n    }\n}\n\n/// Handle a TLS connection\nasync fn handle_tls_connection<S>(stream: S, registry: SharedRegistry) -> Result<()>\nwhere\n    S: AsyncRead + AsyncWrite + Unpin + Send + 'static,\n{\n    // For TLS connections, we use hyper directly (no WebSocket peek needed for now)\n    let io = TokioIo::new(stream);\n    let service = service_fn(move |req| {\n        let registry = registry.clone();\n        async move { handle_http_request(req, registry).await }\n    });\n\n    if let Err(e) = http1::Builder::new().serve_connection(io, service).await {\n        if !e.to_string().contains(\"connection reset\") {\n            error!(\"HTTPS proxy connection error: {}\", e);\n        }\n    }\n\n    Ok(())\n}\n\n/// Handle a single connection - detect WebSocket upgrades vs regular HTTP\nasync fn handle_connection(mut stream: TcpStream, registry: SharedRegistry) -> Result<()> {\n    // Peek at the first bytes to parse the HTTP request\n    let mut buf = vec![0u8; 4096];\n    let n = stream.peek(&mut buf).await?;\n    let peek_data = &buf[..n];\n\n    // Parse headers to check for WebSocket upgrade\n    let header_str = String::from_utf8_lossy(peek_data);\n    let is_websocket =\n        header_str.contains(\"Upgrade: websocket\") || header_str.contains(\"upgrade: websocket\");\n\n    // Extract host from headers\n    let host = extract_host_from_headers(&header_str).unwrap_or_default();\n    let domain = host.split(':').next().unwrap_or(&host).to_string();\n\n    // Look up the service\n    let port = {\n        let reg = registry.read().await;\n        reg.get(&domain).map(|s| s.port)\n    };\n\n    if is_websocket {\n        // WebSocket: tunnel raw TCP\n        if let Some(port) = port {\n            handle_websocket_tunnel(stream, port).await?;\n        } else {\n            // No service found - send 404 and close\n            let response = \"HTTP/1.1 404 Not Found\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            stream.write_all(response.as_bytes()).await?;\n        }\n    } else {\n        // Regular HTTP: use hyper\n        let io = TokioIo::new(stream);\n        let service = service_fn(move |req| {\n            let registry = registry.clone();\n            async move { handle_http_request(req, registry).await }\n        });\n\n        if let Err(e) = http1::Builder::new().serve_connection(io, service).await {\n            // Don't log connection reset errors - they're normal\n            if !e.to_string().contains(\"connection reset\") {\n                error!(\"Proxy connection error: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Extract Host header from raw HTTP headers\nfn extract_host_from_headers(headers: &str) -> Option<String> {\n    for line in headers.lines() {\n        let lower = line.to_lowercase();\n        if lower.starts_with(\"host:\") {\n            return Some(line[5..].trim().to_string());\n        }\n    }\n    None\n}\n\n/// Handle WebSocket upgrade by tunneling raw TCP\nasync fn handle_websocket_tunnel(mut client: TcpStream, backend_port: u16) -> Result<()> {\n    use tokio::io::copy_bidirectional;\n\n    // Connect to backend\n    let mut backend = match TcpStream::connect(format!(\"127.0.0.1:{}\", backend_port)).await {\n        Ok(s) => s,\n        Err(e) => {\n            warn!(\"Failed to connect to backend for WebSocket: {}\", e);\n            return Ok(());\n        }\n    };\n\n    // Tunnel all data bidirectionally (including the initial HTTP upgrade request)\n    match copy_bidirectional(&mut client, &mut backend).await {\n        Ok((client_to_backend, backend_to_client)) => {\n            log_info!(\n                \"WebSocket tunnel closed: {} bytes up, {} bytes down\",\n                client_to_backend, backend_to_client\n            );\n        }\n        Err(e) => {\n            // Connection reset is normal when WebSocket closes\n            if !e.to_string().contains(\"reset\") {\n                warn!(\"WebSocket tunnel error: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Handle regular HTTP request\nasync fn handle_http_request(\n    req: Request<Incoming>,\n    registry: SharedRegistry,\n) -> Result<Response<Full<Bytes>>, hyper::Error> {\n    // Extract host from request\n    let host = req\n        .headers()\n        .get(\"host\")\n        .and_then(|h| h.to_str().ok())\n        .unwrap_or(\"\")\n        .to_string();\n\n    // Remove port from host if present\n    let domain = host.split(':').next().unwrap_or(&host).to_string();\n\n    // Look up the service\n    let port = {\n        let reg = registry.read().await;\n        reg.get(&domain).map(|s| s.port)\n    };\n\n    match port {\n        Some(port) => {\n            // Forward the request to the backend\n            match forward_request(req, port).await {\n                Ok(response) => Ok(response),\n                Err(e) => {\n                    warn!(\"Failed to forward request to {}: {}\", domain, e);\n                    Ok(Response::builder()\n                        .status(502)\n                        .body(Full::new(Bytes::from(format!(\"Bad Gateway: {}\", e))))\n                        .unwrap())\n                }\n            }\n        }\n        None => {\n            // Show dashboard for localhost, 404 for unknown domains\n            if domain == \"localhost\" || domain == \"127.0.0.1\" {\n                let path = req.uri().path();\n\n                // Handle kill API endpoint\n                if path.starts_with(\"/api/kill/\") {\n                    let target_domain = path.strip_prefix(\"/api/kill/\").unwrap_or(\"\");\n                    if !target_domain.is_empty() {\n                        let mut reg = registry.write().await;\n                        if let Some(service) = reg.unregister(target_domain) {\n                            unsafe {\n                                libc::kill(service.pid as i32, libc::SIGTERM);\n                            }\n                            log_info!(\"Killed service: {}\", target_domain);\n                            return Ok(Response::builder()\n                                .status(200)\n                                .header(\"content-type\", \"application/json\")\n                                .body(Full::new(Bytes::from(r#\"{\"ok\":true}\"#)))\n                                .unwrap());\n                        } else {\n                            return Ok(Response::builder()\n                                .status(404)\n                                .header(\"content-type\", \"application/json\")\n                                .body(Full::new(Bytes::from(r#\"{\"error\":\"not found\"}\"#)))\n                                .unwrap());\n                        }\n                    }\n                }\n\n                let reg = registry.read().await;\n                let services = reg.list();\n                let html = render_dashboard(&services);\n                Ok(Response::builder()\n                    .status(200)\n                    .header(\"content-type\", \"text/html; charset=utf-8\")\n                    .body(Full::new(Bytes::from(html)))\n                    .unwrap())\n            } else {\n                let reg = registry.read().await;\n                let services = reg.list();\n                let available = services\n                    .iter()\n                    .map(|s| format!(\"  - http://{}\", s.domain))\n                    .collect::<Vec<_>>()\n                    .join(\"\\n\");\n\n                let body = format!(\n                    \"unport: Domain '{}' not found.\\n\\nAvailable services:\\n{}\",\n                    domain,\n                    if available.is_empty() {\n                        \"  (none)\".to_string()\n                    } else {\n                        available\n                    }\n                );\n\n                Ok(Response::builder()\n                    .status(404)\n                    .header(\"content-type\", \"text/plain\")\n                    .body(Full::new(Bytes::from(body)))\n                    .unwrap())\n            }\n        }\n    }\n}\n\nasync fn forward_request(req: Request<Incoming>, port: u16) -> Result<Response<Full<Bytes>>> {\n    // Try localhost (which resolves to IPv4 or IPv6) first, then fallback to 127.0.0.1\n    let stream = match TcpStream::connect(format!(\"localhost:{}\", port)).await {\n        Ok(s) => s,\n        Err(_) => TcpStream::connect(format!(\"127.0.0.1:{}\", port)).await?,\n    };\n    let io = TokioIo::new(stream);\n\n    let (mut sender, conn) = hyper::client::conn::http1::handshake(io).await?;\n\n    tokio::spawn(async move {\n        if let Err(e) = conn.await {\n            error!(\"Connection error: {}\", e);\n        }\n    });\n\n    let (parts, body) = req.into_parts();\n    let body_bytes = body.collect().await?.to_bytes();\n    let new_req = Request::from_parts(parts, Full::new(body_bytes));\n\n    let response = sender.send_request(new_req).await?;\n    let (parts, body) = response.into_parts();\n    let body_bytes = body.collect().await?.to_bytes();\n\n    Ok(Response::from_parts(parts, Full::new(body_bytes)))\n}\n\nfn is_process_alive(pid: u32) -> bool {\n    unsafe { libc::kill(pid as i32, 0) == 0 }\n}\n\nfn render_dashboard(services: &[Service]) -> String {\n    let service_rows = if services.is_empty() {\n        r#\"<tr><td colspan=\"4\" class=\"empty\">No services running. Start one with <code>unport start</code></td></tr>\"#.to_string()\n    } else {\n        services\n            .iter()\n            .map(|s| {\n                let url = format!(\"http://{}\", s.domain);\n                let status = if is_process_alive(s.pid) {\n                    \"running\"\n                } else {\n                    \"stopped\"\n                };\n                let status_class = if is_process_alive(s.pid) {\n                    \"status-running\"\n                } else {\n                    \"status-stopped\"\n                };\n                format!(\n                    r#\"<tr id=\"row-{}\">\n                        <td><span class=\"status-dot {}\"></span>{}</td>\n                        <td class=\"url\">{}</td>\n                        <td>{}</td>\n                        <td class=\"actions\">\n                            <button class=\"btn btn-copy\" onclick=\"copyToClipboard('{}')\">Copy</button>\n                            <a href=\"{}\" class=\"btn btn-go\" target=\"_blank\">Open</a>\n                            <button class=\"btn btn-kill\" onclick=\"killService('{}')\">Kill</button>\n                        </td>\n                    </tr>\"#,\n                    s.domain, status_class, status, url, s.port, url, url, s.domain\n                )\n            })\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    };\n\n    format!(\n        r##\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>unport - Local Development Services</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        body {{\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n            background: #0a0a0a;\n            color: #e5e5e5;\n            min-height: 100vh;\n            padding: 40px 20px;\n        }}\n        .container {{\n            max-width: 800px;\n            margin: 0 auto;\n        }}\n        header {{\n            margin-bottom: 40px;\n        }}\n        h1 {{\n            font-size: 28px;\n            font-weight: 600;\n            color: #fff;\n            margin-bottom: 8px;\n        }}\n        .subtitle {{\n            color: #666;\n            font-size: 14px;\n        }}\n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            background: #141414;\n            border-radius: 8px;\n            overflow: hidden;\n        }}\n        th {{\n            text-align: left;\n            padding: 12px 16px;\n            font-size: 12px;\n            font-weight: 500;\n            color: #666;\n            text-transform: uppercase;\n            letter-spacing: 0.5px;\n            border-bottom: 1px solid #222;\n        }}\n        td {{\n            padding: 16px;\n            border-bottom: 1px solid #1a1a1a;\n            font-size: 14px;\n        }}\n        tr:last-child td {{\n            border-bottom: none;\n        }}\n        tr:hover {{\n            background: #1a1a1a;\n        }}\n        .url {{\n            font-family: 'SF Mono', Monaco, 'Courier New', monospace;\n            color: #3b82f6;\n        }}\n        .status-dot {{\n            display: inline-block;\n            width: 8px;\n            height: 8px;\n            border-radius: 50%;\n            margin-right: 8px;\n        }}\n        .status-running {{\n            background: #22c55e;\n            box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);\n        }}\n        .status-stopped {{\n            background: #ef4444;\n        }}\n        .actions {{\n            display: flex;\n            gap: 8px;\n        }}\n        .btn {{\n            padding: 6px 12px;\n            border-radius: 4px;\n            font-size: 12px;\n            font-weight: 500;\n            cursor: pointer;\n            transition: all 0.15s ease;\n            text-decoration: none;\n            border: none;\n        }}\n        .btn-copy {{\n            background: #222;\n            color: #e5e5e5;\n            border: 1px solid #333;\n        }}\n        .btn-copy:hover {{\n            background: #333;\n            border-color: #444;\n        }}\n        .btn-go {{\n            background: #3b82f6;\n            color: #fff;\n        }}\n        .btn-go:hover {{\n            background: #2563eb;\n        }}\n        .btn-kill {{\n            background: #dc2626;\n            color: #fff;\n        }}\n        .btn-kill:hover {{\n            background: #b91c1c;\n        }}\n        .empty {{\n            text-align: center;\n            color: #666;\n            padding: 40px 16px;\n        }}\n        code {{\n            background: #222;\n            padding: 2px 6px;\n            border-radius: 4px;\n            font-family: 'SF Mono', Monaco, 'Courier New', monospace;\n            font-size: 13px;\n        }}\n        .toast {{\n            position: fixed;\n            bottom: 20px;\n            left: 50%;\n            transform: translateX(-50%) translateY(100px);\n            background: #22c55e;\n            color: #fff;\n            padding: 12px 24px;\n            border-radius: 6px;\n            font-size: 14px;\n            font-weight: 500;\n            opacity: 0;\n            transition: all 0.3s ease;\n        }}\n        .toast.show {{\n            transform: translateX(-50%) translateY(0);\n            opacity: 1;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>unport</h1>\n            <p class=\"subtitle\">Local Development Services</p>\n        </header>\n        <table>\n            <thead>\n                <tr>\n                    <th>Status</th>\n                    <th>URL</th>\n                    <th>Port</th>\n                    <th>Actions</th>\n                </tr>\n            </thead>\n            <tbody>\n                {}\n            </tbody>\n        </table>\n    </div>\n    <div class=\"toast\" id=\"toast\">Copied to clipboard</div>\n    <script>\n        function copyToClipboard(text) {{\n            navigator.clipboard.writeText(text).then(() => {{\n                showToast('Copied to clipboard');\n            }});\n        }}\n        function killService(domain) {{\n            if (confirm('Kill ' + domain + '?')) {{\n                fetch('/api/kill/' + domain, {{ method: 'POST' }})\n                    .then(r => r.json())\n                    .then(data => {{\n                        if (data.ok) {{\n                            const row = document.getElementById('row-' + domain);\n                            if (row) row.remove();\n                            showToast('Killed ' + domain);\n                        }} else {{\n                            showToast('Failed to kill service');\n                        }}\n                    }})\n                    .catch(() => showToast('Failed to kill service'));\n            }}\n        }}\n        function showToast(msg) {{\n            const toast = document.getElementById('toast');\n            toast.textContent = msg;\n            toast.classList.add('show');\n            setTimeout(() => toast.classList.remove('show'), 2000);\n        }}\n    </script>\n</body>\n</html>\"##,\n        service_rows\n    )\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":177},{"path":["/","Users","ozan","Projects","unport","src","tls.rs"],"content":"use anyhow::{Context, Result};\nuse rcgen::{BasicConstraints, CertificateParams, DnType, IsCa, KeyPair, KeyUsagePurpose, SanType};\nuse rustls_pemfile::{certs, private_key};\nuse std::fs;\nuse std::io::BufReader;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse tokio_rustls::rustls::pki_types::{CertificateDer, PrivateKeyDer};\nuse tokio_rustls::rustls::ServerConfig;\nuse tokio_rustls::TlsAcceptor;\n\nuse crate::log_info;\nuse crate::types::unport_dir;\n\n/// Get the CA key path\npub fn ca_key_path() -> PathBuf {\n    unport_dir().join(\"ca.key\")\n}\n\n/// Get the CA cert path\npub fn ca_cert_path() -> PathBuf {\n    unport_dir().join(\"ca.crt\")\n}\n\n/// Get the certs directory\npub fn certs_dir() -> PathBuf {\n    unport_dir().join(\"certs\")\n}\n\n/// Get the localhost key path\npub fn localhost_key_path() -> PathBuf {\n    certs_dir().join(\"localhost.key\")\n}\n\n/// Get the localhost cert path\npub fn localhost_cert_path() -> PathBuf {\n    certs_dir().join(\"localhost.crt\")\n}\n\n/// Ensure the CA exists, creating it if necessary\npub fn ensure_ca() -> Result<()> {\n    let key_path = ca_key_path();\n    let cert_path = ca_cert_path();\n\n    if key_path.exists() && cert_path.exists() {\n        return Ok(());\n    }\n\n    // Generate CA key pair\n    let key_pair = KeyPair::generate().context(\"Failed to generate CA key pair\")?;\n\n    // Configure CA certificate\n    let mut params = CertificateParams::default();\n    params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n    params.key_usages = vec![\n        KeyUsagePurpose::KeyCertSign,\n        KeyUsagePurpose::CrlSign,\n    ];\n    params\n        .distinguished_name\n        .push(DnType::CommonName, \"unport Local CA\");\n    params\n        .distinguished_name\n        .push(DnType::OrganizationName, \"unport\");\n\n    // Generate CA certificate\n    let cert = params\n        .self_signed(&key_pair)\n        .context(\"Failed to generate CA certificate\")?;\n\n    // Write CA key and cert\n    fs::write(&key_path, key_pair.serialize_pem()).context(\"Failed to write CA key\")?;\n    fs::write(&cert_path, cert.pem()).context(\"Failed to write CA cert\")?;\n\n    log_info!(\"CA certificate created at {:?}\", cert_path);\n\n    Ok(())\n}\n\n/// Generate a certificate with the given domains as SANs\npub fn generate_cert(domains: &[String]) -> Result<()> {\n    let key_path = localhost_key_path();\n    let cert_path = localhost_cert_path();\n\n    // Ensure certs directory exists\n    fs::create_dir_all(certs_dir()).context(\"Failed to create certs directory\")?;\n\n    // Load CA key\n    let ca_key_pem = fs::read_to_string(ca_key_path()).context(\"Failed to read CA key\")?;\n    let ca_key_pair = KeyPair::from_pem(&ca_key_pem).context(\"Failed to parse CA key\")?;\n\n    // Recreate CA cert params for signing\n    let mut ca_params = CertificateParams::default();\n    ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n    ca_params.key_usages = vec![KeyUsagePurpose::KeyCertSign, KeyUsagePurpose::CrlSign];\n    ca_params\n        .distinguished_name\n        .push(DnType::CommonName, \"unport Local CA\");\n    ca_params\n        .distinguished_name\n        .push(DnType::OrganizationName, \"unport\");\n    let ca_cert = ca_params\n        .self_signed(&ca_key_pair)\n        .context(\"Failed to reconstruct CA cert\")?;\n\n    // Generate server key pair\n    let server_key_pair = KeyPair::generate().context(\"Failed to generate server key pair\")?;\n\n    // Build SANs list\n    // Note: *.localhost wildcard doesn't work in OpenSSL/LibreSSL because it requires\n    // at least 2 dots after the wildcard (e.g., *.example.com works, *.localhost doesn't)\n    // So we add explicit domain SANs for each registered service\n    let mut sans: Vec<SanType> = vec![\n        SanType::DnsName(\"localhost\".try_into().unwrap()),\n        SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),\n    ];\n\n    // Add each domain explicitly\n    for domain in domains {\n        if let Ok(name) = domain.as_str().try_into() {\n            sans.push(SanType::DnsName(name));\n        }\n    }\n\n    let mut params = CertificateParams::default();\n    params.subject_alt_names = sans;\n    params\n        .distinguished_name\n        .push(DnType::CommonName, \"localhost\");\n    params\n        .distinguished_name\n        .push(DnType::OrganizationName, \"unport\");\n\n    // Sign with CA\n    let server_cert = params\n        .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n        .context(\"Failed to sign server certificate\")?;\n\n    // Write server key and cert\n    fs::write(&key_path, server_key_pair.serialize_pem()).context(\"Failed to write server key\")?;\n    fs::write(&cert_path, server_cert.pem()).context(\"Failed to write server cert\")?;\n\n    if domains.is_empty() {\n        log_info!(\"TLS certificate generated for: localhost\");\n    } else {\n        log_info!(\"TLS certificate generated for: localhost, {}\", domains.join(\", \"));\n    }\n\n    Ok(())\n}\n\n/// Ensure a basic cert exists (for initial startup)\npub fn ensure_cert() -> Result<()> {\n    let key_path = localhost_key_path();\n    let cert_path = localhost_cert_path();\n\n    if key_path.exists() && cert_path.exists() {\n        return Ok(());\n    }\n\n    generate_cert(&[])\n}\n\n/// Load TLS configuration for the HTTPS server\npub fn load_tls_config() -> Result<TlsAcceptor> {\n    let cert_path = localhost_cert_path();\n    let key_path = localhost_key_path();\n    let ca_path = ca_cert_path();\n\n    // Load server certificate\n    let cert_file = fs::File::open(&cert_path).context(\"Failed to open cert file\")?;\n    let mut cert_reader = BufReader::new(cert_file);\n    let mut cert_chain: Vec<CertificateDer<'static>> = certs(&mut cert_reader)\n        .collect::<Result<Vec<_>, _>>()\n        .context(\"Failed to parse certificates\")?;\n\n    // Load CA certificate and add to chain (required for clients to verify)\n    let ca_file = fs::File::open(&ca_path).context(\"Failed to open CA cert file\")?;\n    let mut ca_reader = BufReader::new(ca_file);\n    let ca_certs: Vec<CertificateDer<'static>> = certs(&mut ca_reader)\n        .collect::<Result<Vec<_>, _>>()\n        .context(\"Failed to parse CA certificate\")?;\n    cert_chain.extend(ca_certs);\n\n    // Load private key\n    let key_file = fs::File::open(&key_path).context(\"Failed to open key file\")?;\n    let mut key_reader = BufReader::new(key_file);\n    let key: PrivateKeyDer<'static> = private_key(&mut key_reader)\n        .context(\"Failed to parse private key\")?\n        .context(\"No private key found\")?;\n\n    // Build TLS config\n    let config = ServerConfig::builder()\n        .with_no_client_auth()\n        .with_single_cert(cert_chain, key)\n        .context(\"Failed to build TLS config\")?;\n\n    log_info!(\"TLS configuration loaded\");\n    Ok(TlsAcceptor::from(Arc::new(config)))\n}\n\n/// Initialize TLS (ensure CA and cert exist, return acceptor)\npub fn init_tls() -> Result<TlsAcceptor> {\n    ensure_ca()?;\n    ensure_cert()?;\n    load_tls_config()\n}\n\n/// Delete generated certificates (forces regeneration on next daemon start)\npub fn clean_certs() -> Result<()> {\n    let cert_path = localhost_cert_path();\n    let key_path = localhost_key_path();\n\n    let mut deleted = false;\n\n    if cert_path.exists() {\n        fs::remove_file(&cert_path).context(\"Failed to delete certificate\")?;\n        println!(\"Deleted: {:?}\", cert_path);\n        deleted = true;\n    }\n\n    if key_path.exists() {\n        fs::remove_file(&key_path).context(\"Failed to delete key\")?;\n        println!(\"Deleted: {:?}\", key_path);\n        deleted = true;\n    }\n\n    if deleted {\n        println!(\"✓ Certificates cleaned. They will be regenerated on next daemon start with --https.\");\n    } else {\n        println!(\"No certificates to clean.\");\n    }\n\n    Ok(())\n}\n\n/// Add or remove the CA certificate from the system trust store\npub fn trust_ca(remove: bool) -> Result<()> {\n    let ca_path = ca_cert_path();\n\n    if !ca_path.exists() {\n        anyhow::bail!(\n            \"CA certificate not found at {:?}. Start the daemon with --https first.\",\n            ca_path\n        );\n    }\n\n    if remove {\n        remove_ca_from_trust_store(&ca_path)\n    } else {\n        add_ca_to_trust_store(&ca_path)\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nfn add_ca_to_trust_store(ca_path: &std::path::Path) -> Result<()> {\n    use std::process::Command;\n\n    println!(\"Adding CA to macOS system trust store...\");\n\n    // First, remove any existing certificate with the same name to avoid conflicts\n    let _ = Command::new(\"security\")\n        .args([\n            \"delete-certificate\",\n            \"-c\",\n            \"unport Local CA\",\n            \"/Library/Keychains/System.keychain\",\n        ])\n        .output();\n\n    // Add the certificate with explicit SSL trust policy\n    let status = Command::new(\"security\")\n        .args([\n            \"add-trusted-cert\",\n            \"-d\",\n            \"-r\",\n            \"trustRoot\",\n            \"-p\",\n            \"ssl\",\n            \"-p\",\n            \"basic\",\n            \"-k\",\n            \"/Library/Keychains/System.keychain\",\n        ])\n        .arg(ca_path)\n        .status()\n        .context(\"Failed to run security command\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"Failed to add CA to trust store. Make sure you're running with sudo.\");\n    }\n\n    println!(\"✓ CA added to system trust store\");\n    println!(\"✓ https://*.localhost is now trusted\");\n\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\nfn remove_ca_from_trust_store(ca_path: &std::path::Path) -> Result<()> {\n    use std::process::Command;\n\n    println!(\"Removing CA from macOS system trust store...\");\n\n    let status = Command::new(\"security\")\n        .args([\"remove-trusted-cert\", \"-d\"])\n        .arg(ca_path)\n        .status()\n        .context(\"Failed to run security command\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"Failed to remove CA from trust store. Make sure you're running with sudo.\");\n    }\n\n    println!(\"✓ CA removed from system trust store\");\n\n    Ok(())\n}\n\n#[cfg(target_os = \"linux\")]\nfn add_ca_to_trust_store(ca_path: &std::path::Path) -> Result<()> {\n    use std::process::Command;\n\n    println!(\"Adding CA to Linux system trust store...\");\n\n    let dest = std::path::Path::new(\"/usr/local/share/ca-certificates/unport-ca.crt\");\n    fs::copy(ca_path, dest).context(\"Failed to copy CA certificate. Run with sudo.\")?;\n\n    let status = Command::new(\"update-ca-certificates\")\n        .status()\n        .context(\"Failed to run update-ca-certificates\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"Failed to update CA certificates\");\n    }\n\n    println!(\"✓ CA added to system trust store\");\n    println!(\"✓ https://*.localhost is now trusted\");\n\n    try_add_to_firefox_nss(ca_path);\n\n    Ok(())\n}\n\n#[cfg(target_os = \"linux\")]\nfn remove_ca_from_trust_store(_ca_path: &std::path::Path) -> Result<()> {\n    use std::process::Command;\n\n    println!(\"Removing CA from Linux system trust store...\");\n\n    let dest = std::path::Path::new(\"/usr/local/share/ca-certificates/unport-ca.crt\");\n    if dest.exists() {\n        fs::remove_file(dest).context(\"Failed to remove CA certificate. Run with sudo.\")?;\n    }\n\n    let status = Command::new(\"update-ca-certificates\")\n        .status()\n        .context(\"Failed to run update-ca-certificates\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"Failed to update CA certificates\");\n    }\n\n    println!(\"✓ CA removed from system trust store\");\n\n    Ok(())\n}\n\n#[cfg(target_os = \"linux\")]\nfn try_add_to_firefox_nss(ca_path: &std::path::Path) {\n    use std::process::Command;\n\n    if Command::new(\"certutil\").arg(\"--version\").output().is_err() {\n        println!(\"Note: Install libnss3-tools to trust CA in Firefox\");\n        return;\n    }\n\n    let home = dirs::home_dir().unwrap_or_default();\n    let firefox_dir = home.join(\".mozilla/firefox\");\n\n    if !firefox_dir.exists() {\n        return;\n    }\n\n    if let Ok(entries) = fs::read_dir(&firefox_dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_dir() && path.join(\"cert9.db\").exists() {\n                let _ = Command::new(\"certutil\")\n                    .args([\"-A\", \"-n\", \"unport CA\", \"-t\", \"C,,\", \"-i\"])\n                    .arg(ca_path)\n                    .args([\"-d\"])\n                    .arg(&path)\n                    .status();\n                println!(\"✓ CA added to Firefox profile at {:?}\", path);\n            }\n        }\n    }\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\nfn add_ca_to_trust_store(ca_path: &std::path::Path) -> Result<()> {\n    println!(\"Automatic trust store installation not supported on this OS.\");\n    println!(\"Please manually trust the CA certificate at: {:?}\", ca_path);\n    Ok(())\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\nfn remove_ca_from_trust_store(_ca_path: &std::path::Path) -> Result<()> {\n    println!(\"Automatic trust store removal not supported on this OS.\");\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use rcgen::{BasicConstraints, CertificateParams, DnType, IsCa, KeyPair, KeyUsagePurpose, SanType};\n    use std::fs;\n    use tempfile::tempdir;\n    use x509_parser::prelude::*;\n\n    fn parse_pem(input: &str) -> Result<::pem::Pem, ::pem::PemError> {\n        ::pem::parse(input)\n    }\n\n    #[test]\n    fn test_ca_generation() {\n        let dir = tempdir().unwrap();\n        let key_path = dir.path().join(\"ca.key\");\n        let cert_path = dir.path().join(\"ca.crt\");\n\n        // Generate CA\n        let key_pair = KeyPair::generate().unwrap();\n        let mut params = CertificateParams::default();\n        params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        params\n            .distinguished_name\n            .push(DnType::CommonName, \"Test CA\");\n\n        let cert = params.self_signed(&key_pair).unwrap();\n\n        fs::write(&key_path, key_pair.serialize_pem()).unwrap();\n        fs::write(&cert_path, cert.pem()).unwrap();\n\n        assert!(key_path.exists());\n        assert!(cert_path.exists());\n\n        // Verify PEM format\n        let key_content = fs::read_to_string(&key_path).unwrap();\n        let cert_content = fs::read_to_string(&cert_path).unwrap();\n        assert!(key_content.contains(\"BEGIN PRIVATE KEY\"));\n        assert!(cert_content.contains(\"BEGIN CERTIFICATE\"));\n    }\n\n    #[test]\n    fn test_generate_cert_with_explicit_domains() {\n        let dir = tempdir().unwrap();\n\n        // Set up test environment\n        std::env::set_var(\"HOME\", dir.path());\n        let unport_dir = dir.path().join(\".unport\");\n        fs::create_dir_all(&unport_dir).unwrap();\n        let certs_dir = unport_dir.join(\"certs\");\n        fs::create_dir_all(&certs_dir).unwrap();\n\n        // Generate CA first\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        ca_params.key_usages = vec![KeyUsagePurpose::KeyCertSign, KeyUsagePurpose::CrlSign];\n        ca_params\n            .distinguished_name\n            .push(DnType::CommonName, \"unport Local CA\");\n        ca_params\n            .distinguished_name\n            .push(DnType::OrganizationName, \"unport\");\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        fs::write(unport_dir.join(\"ca.key\"), ca_key_pair.serialize_pem()).unwrap();\n        fs::write(unport_dir.join(\"ca.crt\"), ca_cert.pem()).unwrap();\n\n        // Generate server certificate with explicit domains\n        let domains = vec![\n            \"game-analytics-api.localhost\".to_string(),\n            \"dashboard.localhost\".to_string(),\n            \"api.localhost\".to_string(),\n        ];\n\n        let server_key_pair = KeyPair::generate().unwrap();\n\n        let mut sans: Vec<SanType> = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),\n        ];\n        for domain in &domains {\n            sans.push(SanType::DnsName(domain.as_str().try_into().unwrap()));\n        }\n\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = sans;\n        params\n            .distinguished_name\n            .push(DnType::CommonName, \"localhost\");\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n        fs::write(certs_dir.join(\"localhost.crt\"), &cert_pem).unwrap();\n        fs::write(certs_dir.join(\"localhost.key\"), server_key_pair.serialize_pem()).unwrap();\n\n        // Parse the certificate and verify SANs\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        // Get Subject Alternative Names\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .expect(\"Certificate should have SAN extension\");\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        // Verify all expected domains are in the SANs\n        assert!(dns_names.contains(&\"localhost\"), \"Should contain localhost\");\n        assert!(\n            dns_names.contains(&\"game-analytics-api.localhost\"),\n            \"Should contain game-analytics-api.localhost\"\n        );\n        assert!(\n            dns_names.contains(&\"dashboard.localhost\"),\n            \"Should contain dashboard.localhost\"\n        );\n        assert!(\n            dns_names.contains(&\"api.localhost\"),\n            \"Should contain api.localhost\"\n        );\n    }\n\n    #[test]\n    fn test_cert_with_hyphenated_subdomain() {\n        // This test verifies that domains with hyphens work correctly\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::DnsName(\"my-cool-app.localhost\".try_into().unwrap()),\n            SanType::DnsName(\"another-hyphenated-domain.localhost\".try_into().unwrap()),\n        ];\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n\n        // Parse and verify\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .expect(\"Certificate should have SAN extension\");\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        assert!(dns_names.contains(&\"my-cool-app.localhost\"));\n        assert!(dns_names.contains(&\"another-hyphenated-domain.localhost\"));\n    }\n\n    #[test]\n    fn test_cert_includes_ip_address() {\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),\n        ];\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n\n        // Parse and verify\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .expect(\"Certificate should have SAN extension\");\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let has_ip = san.general_names.iter().any(|name| {\n            matches!(name, GeneralName::IPAddress(ip) if ip == &[127, 0, 0, 1])\n        });\n\n        assert!(has_ip, \"Certificate should include 127.0.0.1 IP address\");\n    }\n\n    #[test]\n    fn test_empty_domains_generates_localhost_only() {\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n\n        // Simulate generate_cert with empty domains\n        let domains: Vec<String> = vec![];\n        let mut sans: Vec<SanType> = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),\n        ];\n        for domain in &domains {\n            if let Ok(name) = domain.as_str().try_into() {\n                sans.push(SanType::DnsName(name));\n            }\n        }\n\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = sans;\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n\n        // Parse and verify\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .expect(\"Certificate should have SAN extension\");\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        assert_eq!(dns_names.len(), 1, \"Should only have localhost\");\n        assert!(dns_names.contains(&\"localhost\"));\n    }\n\n    #[test]\n    fn test_cert_with_many_domains() {\n        // Test certificate generation with many domains (stress test)\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n\n        // Generate 50 domains\n        let mut sans: Vec<SanType> = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),\n        ];\n\n        for i in 0..50 {\n            let domain = format!(\"service-{}.localhost\", i);\n            sans.push(SanType::DnsName(domain.as_str().try_into().unwrap()));\n        }\n\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = sans;\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n\n        // Parse and verify\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .expect(\"Certificate should have SAN extension\");\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        // Should have localhost + 50 services\n        assert_eq!(dns_names.len(), 51, \"Should have 51 DNS names\");\n        assert!(dns_names.contains(&\"service-0.localhost\"));\n        assert!(dns_names.contains(&\"service-49.localhost\"));\n    }\n\n    #[test]\n    fn test_cert_with_special_characters_in_subdomain() {\n        // Test domains with numbers and valid special chars\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::DnsName(\"app123.localhost\".try_into().unwrap()),\n            SanType::DnsName(\"my-app-v2.localhost\".try_into().unwrap()),\n            SanType::DnsName(\"test--double-dash.localhost\".try_into().unwrap()),\n        ];\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .unwrap();\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        assert!(dns_names.contains(&\"app123.localhost\"));\n        assert!(dns_names.contains(&\"my-app-v2.localhost\"));\n        assert!(dns_names.contains(&\"test--double-dash.localhost\"));\n    }\n\n    #[test]\n    fn test_cert_with_long_subdomain() {\n        // Test with a long but valid subdomain (max label is 63 chars)\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n\n        // 63 character subdomain (max allowed)\n        let long_subdomain = \"a\".repeat(63);\n        let long_domain = format!(\"{}.localhost\", long_subdomain);\n\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n            SanType::DnsName(long_domain.as_str().try_into().unwrap()),\n        ];\n\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        let san_ext = cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_SUBJECT_ALT_NAME)\n            .unwrap();\n\n        let san = match san_ext.parsed_extension() {\n            ParsedExtension::SubjectAlternativeName(san) => san,\n            _ => panic!(\"Expected SubjectAlternativeName\"),\n        };\n\n        let dns_names: Vec<&str> = san\n            .general_names\n            .iter()\n            .filter_map(|name| match name {\n                GeneralName::DNSName(dns) => Some(*dns),\n                _ => None,\n            })\n            .collect();\n\n        assert!(dns_names.contains(&long_domain.as_str()));\n    }\n\n    #[test]\n    fn test_ca_certificate_properties() {\n        // Verify CA certificate has correct properties\n        let key_pair = KeyPair::generate().unwrap();\n        let mut params = CertificateParams::default();\n        params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        params.key_usages = vec![KeyUsagePurpose::KeyCertSign, KeyUsagePurpose::CrlSign];\n        params\n            .distinguished_name\n            .push(DnType::CommonName, \"unport Local CA\");\n        params\n            .distinguished_name\n            .push(DnType::OrganizationName, \"unport\");\n\n        let cert = params.self_signed(&key_pair).unwrap();\n        let cert_pem = cert.pem();\n\n        let pem = parse_pem(&cert_pem).unwrap();\n        let (_, x509_cert) = X509Certificate::from_der(pem.contents()).unwrap();\n\n        // Verify it's a CA certificate\n        let basic_constraints = x509_cert\n            .extensions()\n            .iter()\n            .find(|ext| ext.oid == x509_parser::oid_registry::OID_X509_EXT_BASIC_CONSTRAINTS);\n\n        assert!(basic_constraints.is_some(), \"CA cert should have BasicConstraints\");\n\n        // Verify subject\n        let subject = x509_cert.subject();\n        let cn = subject.iter_common_name().next();\n        assert!(cn.is_some());\n    }\n\n    #[test]\n    fn test_server_cert_signed_by_ca() {\n        // Verify server certificate is properly signed by CA\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        ca_params\n            .distinguished_name\n            .push(DnType::CommonName, \"Test CA\");\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n        let mut server_params = CertificateParams::default();\n        server_params.subject_alt_names = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n        ];\n        server_params\n            .distinguished_name\n            .push(DnType::CommonName, \"localhost\");\n\n        let server_cert = server_params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let server_pem = server_cert.pem();\n        let ca_pem = ca_cert.pem();\n\n        // Parse both certificates\n        let server_parsed = parse_pem(&server_pem).unwrap();\n        let ca_parsed = parse_pem(&ca_pem).unwrap();\n\n        let (_, server_x509) = X509Certificate::from_der(server_parsed.contents()).unwrap();\n        let (_, ca_x509) = X509Certificate::from_der(ca_parsed.contents()).unwrap();\n\n        // Server cert issuer should match CA subject\n        assert_eq!(\n            server_x509.issuer(),\n            ca_x509.subject(),\n            \"Server cert issuer should match CA subject\"\n        );\n    }\n\n    #[test]\n    fn test_duplicate_domains_handled() {\n        // Test that duplicate domains don't cause issues\n        let ca_key_pair = KeyPair::generate().unwrap();\n        let mut ca_params = CertificateParams::default();\n        ca_params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);\n        let ca_cert = ca_params.self_signed(&ca_key_pair).unwrap();\n\n        let server_key_pair = KeyPair::generate().unwrap();\n\n        // Add same domain twice (simulating edge case)\n        let domains = vec![\n            \"api.localhost\".to_string(),\n            \"api.localhost\".to_string(), // duplicate\n            \"web.localhost\".to_string(),\n        ];\n\n        let mut sans: Vec<SanType> = vec![\n            SanType::DnsName(\"localhost\".try_into().unwrap()),\n        ];\n\n        for domain in &domains {\n            if let Ok(name) = domain.as_str().try_into() {\n                sans.push(SanType::DnsName(name));\n            }\n        }\n\n        let mut params = CertificateParams::default();\n        params.subject_alt_names = sans;\n\n        // Should not panic with duplicates\n        let server_cert = params\n            .signed_by(&server_key_pair, &ca_cert, &ca_key_pair)\n            .unwrap();\n\n        let cert_pem = server_cert.pem();\n        assert!(cert_pem.contains(\"BEGIN CERTIFICATE\"));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":160},{"path":["/","Users","ozan","Projects","unport","src","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// A registered service in the daemon\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Service {\n    pub domain: String,\n    pub port: u16,\n    pub pid: u32,\n    pub directory: PathBuf,\n}\n\n/// Messages sent from CLI to daemon via Unix socket\n#[derive(Debug, Serialize, Deserialize)]\npub enum Request {\n    /// Register a new service\n    Register {\n        domain: String,\n        port: u16,\n        pid: u32,\n        directory: PathBuf,\n    },\n    /// Unregister a service\n    Unregister { domain: String },\n    /// Get an available port\n    GetPort,\n    /// List all services\n    List,\n    /// Stop a service by domain\n    Stop { domain: String },\n    /// Shutdown the daemon\n    Shutdown,\n    /// Check if HTTPS is enabled\n    HttpsStatus,\n}\n\n/// Messages sent from daemon to CLI\n#[derive(Debug, Serialize, Deserialize)]\npub enum Response {\n    /// Success with optional message\n    Ok(Option<String>),\n    /// Assigned port number\n    Port(u16),\n    /// List of services\n    Services(Vec<Service>),\n    /// Error message\n    Error(String),\n    /// HTTPS status (enabled/disabled)\n    HttpsEnabled(bool),\n}\n\n/// Port assignment range\npub const PORT_RANGE_START: u16 = 4000;\npub const PORT_RANGE_END: u16 = 5000;\n\n/// Get the unport home directory (~/.unport)\npub fn unport_dir() -> PathBuf {\n    dirs::home_dir()\n        .expect(\"Could not find home directory\")\n        .join(\".unport\")\n}\n\n/// Get the Unix socket path\npub fn socket_path() -> PathBuf {\n    unport_dir().join(\"unport.sock\")\n}\n\n/// Get the PID file path\npub fn pid_path() -> PathBuf {\n    unport_dir().join(\"unport.pid\")\n}\n\n/// Get the registry file path\npub fn registry_path() -> PathBuf {\n    unport_dir().join(\"registry.json\")\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":8},{"path":["/","Users","ozan","Projects","unport","tests","config_tests.rs"],"content":"use std::fs;\nuse std::path::Path;\nuse tempfile::tempdir;\n\n#[derive(Debug, serde::Deserialize, PartialEq)]\nstruct Config {\n    domain: String,\n    start: Option<String>,\n    #[serde(rename = \"portEnv\")]\n    port_env: Option<String>,\n    #[serde(rename = \"portArg\")]\n    port_arg: Option<String>,\n}\n\nimpl Config {\n    fn load(dir: &Path) -> Result<Self, Box<dyn std::error::Error>> {\n        let config_path = dir.join(\"unport.json\");\n        let content = fs::read_to_string(&config_path)?;\n        let config: Config = serde_json::from_str(&content)?;\n        Ok(config)\n    }\n\n    fn full_domain(&self) -> String {\n        format!(\"{}.localhost\", self.domain)\n    }\n}\n\n#[test]\nfn test_load_minimal_config() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\"domain\": \"myapp\"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"myapp\");\n    assert_eq!(config.start, None);\n    assert_eq!(config.port_env, None);\n    assert_eq!(config.port_arg, None);\n}\n\n#[test]\nfn test_load_full_config() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"api\",\n        \"start\": \"npm run start\",\n        \"portEnv\": \"SERVER_PORT\",\n        \"portArg\": \"--port\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"api\");\n    assert_eq!(config.start, Some(\"npm run start\".to_string()));\n    assert_eq!(config.port_env, Some(\"SERVER_PORT\".to_string()));\n    assert_eq!(config.port_arg, Some(\"--port\".to_string()));\n}\n\n#[test]\nfn test_load_config_with_custom_start() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"backend\",\n        \"start\": \"python app.py\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"backend\");\n    assert_eq!(config.start, Some(\"python app.py\".to_string()));\n}\n\n#[test]\nfn test_load_config_with_port_env() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"service\",\n        \"portEnv\": \"HTTP_PORT\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.port_env, Some(\"HTTP_PORT\".to_string()));\n}\n\n#[test]\nfn test_load_config_with_port_arg() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"service\",\n        \"portArg\": \"-p\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.port_arg, Some(\"-p\".to_string()));\n}\n\n#[test]\nfn test_full_domain() {\n    let config = Config {\n        domain: \"myapp\".to_string(),\n        start: None,\n        port_env: None,\n        port_arg: None,\n    };\n\n    assert_eq!(config.full_domain(), \"myapp.localhost\");\n}\n\n#[test]\nfn test_full_domain_api() {\n    let config = Config {\n        domain: \"api\".to_string(),\n        start: None,\n        port_env: None,\n        port_arg: None,\n    };\n\n    assert_eq!(config.full_domain(), \"api.localhost\");\n}\n\n#[test]\nfn test_full_domain_with_hyphen() {\n    let config = Config {\n        domain: \"my-cool-app\".to_string(),\n        start: None,\n        port_env: None,\n        port_arg: None,\n    };\n\n    assert_eq!(config.full_domain(), \"my-cool-app.localhost\");\n}\n\n#[test]\nfn test_missing_config_file() {\n    let dir = tempdir().unwrap();\n    let result = Config::load(dir.path());\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_invalid_json() {\n    let dir = tempdir().unwrap();\n    fs::write(dir.path().join(\"unport.json\"), \"{ invalid json }\").unwrap();\n\n    let result = Config::load(dir.path());\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_missing_required_field() {\n    let dir = tempdir().unwrap();\n    // Missing \"domain\" field\n    fs::write(dir.path().join(\"unport.json\"), r#\"{\"start\": \"npm run dev\"}\"#).unwrap();\n\n    let result = Config::load(dir.path());\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_extra_fields_ignored() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"myapp\",\n        \"extra_field\": \"should be ignored\",\n        \"another_field\": 123\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"myapp\");\n}\n\n#[test]\nfn test_empty_domain() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\"domain\": \"\"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"\");\n    assert_eq!(config.full_domain(), \".localhost\");\n}\n\n#[test]\nfn test_unicode_domain() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\"domain\": \"my-app-测试\"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"my-app-测试\");\n}\n\n#[test]\nfn test_domain_with_numbers() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\"domain\": \"app123\"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"app123\");\n    assert_eq!(config.full_domain(), \"app123.localhost\");\n}\n\n#[test]\nfn test_domain_with_underscores() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\"domain\": \"my_app\"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"my_app\");\n}\n\n#[test]\nfn test_very_long_domain() {\n    let dir = tempdir().unwrap();\n    let long_domain = \"a\".repeat(63); // max DNS label length\n    let config_content = format!(r#\"{{\"domain\": \"{}\"}}\"#, long_domain);\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain.len(), 63);\n}\n\n#[test]\nfn test_start_command_with_args() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"api\",\n        \"start\": \"node server.js --env=production --debug\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.start, Some(\"node server.js --env=production --debug\".to_string()));\n}\n\n#[test]\nfn test_start_command_with_pipes() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"api\",\n        \"start\": \"npm run build && npm start\"\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert!(config.start.unwrap().contains(\"&&\"));\n}\n\n#[test]\nfn test_port_env_common_names() {\n    let common_env_vars = vec![\"PORT\", \"HTTP_PORT\", \"SERVER_PORT\", \"APP_PORT\", \"LISTEN_PORT\"];\n\n    for env_var in common_env_vars {\n        let dir = tempdir().unwrap();\n        let config_content = format!(r#\"{{\"domain\": \"app\", \"portEnv\": \"{}\"}}\"#, env_var);\n        fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n        let config = Config::load(dir.path()).unwrap();\n        assert_eq!(config.port_env, Some(env_var.to_string()));\n    }\n}\n\n#[test]\nfn test_port_arg_common_formats() {\n    let common_args = vec![\"--port\", \"-p\", \"-P\", \"--listen\", \"--http-port\"];\n\n    for arg in common_args {\n        let dir = tempdir().unwrap();\n        let config_content = format!(r#\"{{\"domain\": \"app\", \"portArg\": \"{}\"}}\"#, arg);\n        fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n        let config = Config::load(dir.path()).unwrap();\n        assert_eq!(config.port_arg, Some(arg.to_string()));\n    }\n}\n\n#[test]\nfn test_whitespace_in_domain_preserved() {\n    let dir = tempdir().unwrap();\n    // JSON with leading/trailing whitespace in domain value\n    let config_content = r#\"{\"domain\": \"  myapp  \"}\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    // JSON parsing preserves whitespace in strings\n    assert_eq!(config.domain, \"  myapp  \");\n}\n\n#[test]\nfn test_null_optional_fields() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"app\",\n        \"start\": null,\n        \"portEnv\": null,\n        \"portArg\": null\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let config = Config::load(dir.path()).unwrap();\n    assert_eq!(config.domain, \"app\");\n    assert_eq!(config.start, None);\n    assert_eq!(config.port_env, None);\n    assert_eq!(config.port_arg, None);\n}\n\n#[test]\nfn test_config_file_with_bom() {\n    let dir = tempdir().unwrap();\n    // UTF-8 BOM + JSON content\n    let mut content = vec![0xEF, 0xBB, 0xBF]; // UTF-8 BOM\n    content.extend_from_slice(br#\"{\"domain\": \"app\"}\"#);\n    fs::write(dir.path().join(\"unport.json\"), content).unwrap();\n\n    // This might fail depending on how the parser handles BOM\n    let result = Config::load(dir.path());\n    // We just check it doesn't panic\n    let _ = result;\n}\n\n#[test]\nfn test_config_with_comments_fails() {\n    let dir = tempdir().unwrap();\n    // JSON doesn't support comments\n    let config_content = r#\"{\n        \"domain\": \"app\" // this is a comment\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let result = Config::load(dir.path());\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_config_with_trailing_comma_fails() {\n    let dir = tempdir().unwrap();\n    let config_content = r#\"{\n        \"domain\": \"app\",\n    }\"#;\n    fs::write(dir.path().join(\"unport.json\"), config_content).unwrap();\n\n    let result = Config::load(dir.path());\n    assert!(result.is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","ozan","Projects","unport","tests","daemon_tests.rs"],"content":"use std::process::Command;\n\n/// Test that `unport daemon` without subcommand shows help/error\n#[test]\nfn test_daemon_requires_subcommand() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_unport\"))\n        .arg(\"daemon\")\n        .output()\n        .expect(\"Failed to execute command\");\n\n    // Should fail because subcommand is required\n    assert!(!output.status.success(), \"daemon without subcommand should fail\");\n\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let combined = format!(\"{}{}\", stdout, stderr);\n\n    // Should mention available subcommands\n    assert!(\n        combined.contains(\"start\") && combined.contains(\"stop\") && combined.contains(\"status\"),\n        \"Should show available subcommands, got: {}\",\n        combined\n    );\n}\n\n/// Test that `unport daemon start` (without -d) attempts to start\n/// This verifies the CLI parsing works correctly\n#[test]\nfn test_daemon_start_cli_parsing() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_unport\"))\n        .arg(\"daemon\")\n        .arg(\"start\")\n        .arg(\"--help\")\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n\n    // Should show the -d/--detach option\n    assert!(\n        stdout.contains(\"--detach\") || stdout.contains(\"-d\"),\n        \"Should show detach option, got: {}\",\n        stdout\n    );\n}\n\n/// Test that the detach flag is properly recognized\n#[test]\nfn test_daemon_start_detach_flag() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_unport\"))\n        .arg(\"daemon\")\n        .arg(\"start\")\n        .arg(\"-d\")\n        .arg(\"--help\")  // Add help to prevent actual daemon start\n        .output()\n        .expect(\"Failed to execute command\");\n\n    // With --help after -d, clap should still show help\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    assert!(output.status.success() || stdout.contains(\"daemon\"));\n}\n\n/// Verify the exact arguments that would be passed when spawning detached daemon\n/// This is the core test for the bug: spawn must use [\"daemon\", \"start\"] not just [\"daemon\"]\n#[test]\nfn test_detach_spawn_uses_correct_args() {\n    // This test documents the expected behavior:\n    // When spawning a detached daemon, we must pass \"daemon start\" not just \"daemon\"\n\n    // Test that \"daemon start\" works (exits quickly without sudo, but parses correctly)\n    let output = Command::new(env!(\"CARGO_BIN_EXE_unport\"))\n        .args([\"daemon\", \"start\"])\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let combined = format!(\"{}{}\", stdout, stderr);\n\n    // Should NOT show \"daemon <COMMAND>\" help - that would mean args weren't parsed\n    assert!(\n        !combined.contains(\"daemon <COMMAND>\"),\n        \"Should not show subcommand help when 'daemon start' is provided. Got: {}\",\n        combined\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","ozan","Projects","unport","tests","detect_tests.rs"],"content":"use std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\nuse tempfile::tempdir;\n\n// Re-implement detection logic for testing (since we can't import from main crate easily)\n#[derive(Debug, PartialEq)]\nenum PortStrategy {\n    EnvVar(String),\n    CliFlag(String),\n}\n\n#[derive(Debug)]\nstruct Detection {\n    framework: String,\n    start_command: String,\n    port_strategy: PortStrategy,\n}\n\n#[derive(serde::Deserialize)]\nstruct PackageJson {\n    scripts: Option<HashMap<String, String>>,\n    dependencies: Option<HashMap<String, serde_json::Value>>,\n    #[serde(rename = \"devDependencies\")]\n    dev_dependencies: Option<HashMap<String, serde_json::Value>>,\n}\n\nfn merge_deps(\n    deps: &Option<HashMap<String, serde_json::Value>>,\n    dev_deps: &Option<HashMap<String, serde_json::Value>>,\n) -> HashMap<String, serde_json::Value> {\n    let mut all = HashMap::new();\n    if let Some(d) = deps {\n        all.extend(d.clone());\n    }\n    if let Some(d) = dev_deps {\n        all.extend(d.clone());\n    }\n    all\n}\n\nfn detect(dir: &Path) -> Result<Detection, Box<dyn std::error::Error>> {\n    let package_json_path = dir.join(\"package.json\");\n    if package_json_path.exists() {\n        let content = fs::read_to_string(&package_json_path)?;\n        let package: PackageJson = serde_json::from_str(&content)?;\n\n        let all_deps = merge_deps(&package.dependencies, &package.dev_dependencies);\n        let scripts = package.scripts.unwrap_or_default();\n        let dev_script = scripts.get(\"dev\").cloned().unwrap_or_default();\n\n        if all_deps.contains_key(\"next\") {\n            return Ok(Detection {\n                framework: \"Next.js\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"vite\") || dev_script.contains(\"vite\") {\n            return Ok(Detection {\n                framework: \"Vite\".into(),\n                start_command: \"npm run dev --\".into(),\n                port_strategy: PortStrategy::CliFlag(\"--port\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"react-scripts\") {\n            return Ok(Detection {\n                framework: \"Create React App\".into(),\n                start_command: \"npm start\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"@remix-run/dev\") {\n            return Ok(Detection {\n                framework: \"Remix\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"nuxt\") {\n            return Ok(Detection {\n                framework: \"Nuxt\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"@nestjs/core\") {\n            return Ok(Detection {\n                framework: \"NestJS\".into(),\n                start_command: \"npm run start:dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"fastify\") {\n            return Ok(Detection {\n                framework: \"Fastify\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        if all_deps.contains_key(\"express\") {\n            return Ok(Detection {\n                framework: \"Express\".into(),\n                start_command: \"npm run dev\".into(),\n                port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n            });\n        }\n\n        let start_cmd = if scripts.contains_key(\"dev\") {\n            \"npm run dev\"\n        } else if scripts.contains_key(\"start\") {\n            \"npm start\"\n        } else {\n            \"npm run dev\"\n        };\n\n        return Ok(Detection {\n            framework: \"Node.js\".into(),\n            start_command: start_cmd.into(),\n            port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n        });\n    }\n\n    if dir.join(\"Gemfile\").exists() {\n        return Ok(Detection {\n            framework: \"Rails\".into(),\n            start_command: \"rails server\".into(),\n            port_strategy: PortStrategy::CliFlag(\"-p\".into()),\n        });\n    }\n\n    if dir.join(\"manage.py\").exists() {\n        return Ok(Detection {\n            framework: \"Django\".into(),\n            start_command: \"python manage.py runserver\".into(),\n            port_strategy: PortStrategy::CliFlag(\"0.0.0.0:\".into()),\n        });\n    }\n\n    if dir.join(\"go.mod\").exists() {\n        return Ok(Detection {\n            framework: \"Go\".into(),\n            start_command: \"go run .\".into(),\n            port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n        });\n    }\n\n    Ok(Detection {\n        framework: \"Unknown\".into(),\n        start_command: \"npm run dev\".into(),\n        port_strategy: PortStrategy::EnvVar(\"PORT\".into()),\n    })\n}\n\n#[test]\nfn test_detect_nextjs() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"next\": \"13.0.0\",\n            \"react\": \"18.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Next.js\");\n    assert_eq!(result.start_command, \"npm run dev\");\n    assert_eq!(result.port_strategy, PortStrategy::EnvVar(\"PORT\".into()));\n}\n\n#[test]\nfn test_detect_vite_dependency() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"devDependencies\": {\n            \"vite\": \"4.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Vite\");\n    assert_eq!(result.start_command, \"npm run dev --\");\n    assert_eq!(result.port_strategy, PortStrategy::CliFlag(\"--port\".into()));\n}\n\n#[test]\nfn test_detect_vite_in_scripts() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"scripts\": {\n            \"dev\": \"vite\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Vite\");\n}\n\n#[test]\nfn test_detect_create_react_app() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"react-scripts\": \"5.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Create React App\");\n    assert_eq!(result.start_command, \"npm start\");\n}\n\n#[test]\nfn test_detect_express() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"express\": \"4.18.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Express\");\n}\n\n#[test]\nfn test_detect_remix() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"@remix-run/dev\": \"1.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Remix\");\n}\n\n#[test]\nfn test_detect_nuxt() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"nuxt\": \"3.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Nuxt\");\n}\n\n#[test]\nfn test_detect_nestjs() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"@nestjs/core\": \"9.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"NestJS\");\n    assert_eq!(result.start_command, \"npm run start:dev\");\n}\n\n#[test]\nfn test_detect_fastify() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"fastify\": \"4.0.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Fastify\");\n}\n\n#[test]\nfn test_detect_rails() {\n    let dir = tempdir().unwrap();\n    fs::write(dir.path().join(\"Gemfile\"), \"gem 'rails'\").unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Rails\");\n    assert_eq!(result.start_command, \"rails server\");\n    assert_eq!(result.port_strategy, PortStrategy::CliFlag(\"-p\".into()));\n}\n\n#[test]\nfn test_detect_django() {\n    let dir = tempdir().unwrap();\n    fs::write(dir.path().join(\"manage.py\"), \"#!/usr/bin/env python\").unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Django\");\n    assert_eq!(result.start_command, \"python manage.py runserver\");\n    assert_eq!(result.port_strategy, PortStrategy::CliFlag(\"0.0.0.0:\".into()));\n}\n\n#[test]\nfn test_detect_go() {\n    let dir = tempdir().unwrap();\n    fs::write(dir.path().join(\"go.mod\"), \"module example.com/app\\n\\ngo 1.21\").unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Go\");\n    assert_eq!(result.start_command, \"go run .\");\n    assert_eq!(result.port_strategy, PortStrategy::EnvVar(\"PORT\".into()));\n}\n\n#[test]\nfn test_detect_generic_nodejs_with_dev_script() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"scripts\": {\n            \"dev\": \"node index.js\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Node.js\");\n    assert_eq!(result.start_command, \"npm run dev\");\n}\n\n#[test]\nfn test_detect_generic_nodejs_with_start_script() {\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"scripts\": {\n            \"start\": \"node index.js\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Node.js\");\n    assert_eq!(result.start_command, \"npm start\");\n}\n\n#[test]\nfn test_detect_unknown_project() {\n    let dir = tempdir().unwrap();\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Unknown\");\n}\n\n#[test]\nfn test_merge_deps_both() {\n    let mut deps = HashMap::new();\n    deps.insert(\"express\".to_string(), serde_json::json!(\"4.0.0\"));\n\n    let mut dev_deps = HashMap::new();\n    dev_deps.insert(\"jest\".to_string(), serde_json::json!(\"29.0.0\"));\n\n    let merged = merge_deps(&Some(deps), &Some(dev_deps));\n    assert!(merged.contains_key(\"express\"));\n    assert!(merged.contains_key(\"jest\"));\n    assert_eq!(merged.len(), 2);\n}\n\n#[test]\nfn test_merge_deps_only_deps() {\n    let mut deps = HashMap::new();\n    deps.insert(\"express\".to_string(), serde_json::json!(\"4.0.0\"));\n\n    let merged = merge_deps(&Some(deps), &None);\n    assert!(merged.contains_key(\"express\"));\n    assert_eq!(merged.len(), 1);\n}\n\n#[test]\nfn test_merge_deps_only_dev_deps() {\n    let mut dev_deps = HashMap::new();\n    dev_deps.insert(\"jest\".to_string(), serde_json::json!(\"29.0.0\"));\n\n    let merged = merge_deps(&None, &Some(dev_deps));\n    assert!(merged.contains_key(\"jest\"));\n    assert_eq!(merged.len(), 1);\n}\n\n#[test]\nfn test_merge_deps_none() {\n    let merged = merge_deps(&None, &None);\n    assert!(merged.is_empty());\n}\n\n#[test]\nfn test_nextjs_priority_over_express() {\n    // Next.js apps often have express as a dependency too\n    let dir = tempdir().unwrap();\n    let package_json = r#\"{\n        \"dependencies\": {\n            \"next\": \"13.0.0\",\n            \"express\": \"4.18.0\"\n        }\n    }\"#;\n    fs::write(dir.path().join(\"package.json\"), package_json).unwrap();\n\n    let result = detect(dir.path()).unwrap();\n    assert_eq!(result.framework, \"Next.js\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","ozan","Projects","unport","tests","proxy_tests.rs"],"content":"use std::net::TcpListener;\nuse std::sync::atomic::{AtomicU16, Ordering};\n\nstatic TEST_PORT: AtomicU16 = AtomicU16::new(16000);\n\nfn get_test_port() -> u16 {\n    TEST_PORT.fetch_add(1, Ordering::SeqCst)\n}\n\n// Helper function to extract host header\nfn extract_host_from_headers(headers: &str) -> Option<String> {\n    for line in headers.lines() {\n        let lower = line.to_lowercase();\n        if lower.starts_with(\"host:\") {\n            return Some(line[5..].trim().to_string());\n        }\n    }\n    None\n}\n\n// Helper to check if request is WebSocket upgrade\nfn is_websocket_upgrade(headers: &str) -> bool {\n    headers.contains(\"Upgrade: websocket\") || headers.contains(\"upgrade: websocket\")\n}\n\nmod host_extraction {\n    use super::*;\n\n    #[test]\n    fn test_extract_simple_host() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost: myapp.localhost\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"myapp.localhost\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_host_with_port() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost: myapp.localhost:80\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"myapp.localhost:80\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_host_lowercase() {\n        let headers = \"GET / HTTP/1.1\\r\\nhost: myapp.localhost\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"myapp.localhost\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_host_mixed_case() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost: MyApp.LocalHost\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"MyApp.LocalHost\".to_string()));\n    }\n\n    #[test]\n    fn test_missing_host_header() {\n        let headers = \"GET / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, None);\n    }\n\n    #[test]\n    fn test_extract_host_with_whitespace() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost:   myapp.localhost  \\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"myapp.localhost\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_host_multiple_headers() {\n        let headers = \"GET / HTTP/1.1\\r\\nAccept: */*\\r\\nHost: api.localhost\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"api.localhost\".to_string()));\n    }\n\n    #[test]\n    fn test_domain_extraction_from_host() {\n        let host = \"myapp.localhost:80\";\n        let domain = host.split(':').next().unwrap_or(host);\n        assert_eq!(domain, \"myapp.localhost\");\n    }\n\n    #[test]\n    fn test_domain_extraction_without_port() {\n        let host = \"myapp.localhost\";\n        let domain = host.split(':').next().unwrap_or(host);\n        assert_eq!(domain, \"myapp.localhost\");\n    }\n}\n\nmod websocket_detection {\n    use super::*;\n\n    #[test]\n    fn test_detect_websocket_upgrade() {\n        let headers = \"GET /ws HTTP/1.1\\r\\nHost: myapp.localhost\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\\r\\n\";\n        assert!(is_websocket_upgrade(headers));\n    }\n\n    #[test]\n    fn test_detect_websocket_lowercase() {\n        let headers = \"GET /ws HTTP/1.1\\r\\nHost: myapp.localhost\\r\\nupgrade: websocket\\r\\nconnection: upgrade\\r\\n\\r\\n\";\n        assert!(is_websocket_upgrade(headers));\n    }\n\n    #[test]\n    fn test_regular_http_not_websocket() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost: myapp.localhost\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\n        assert!(!is_websocket_upgrade(headers));\n    }\n\n    #[test]\n    fn test_post_request_not_websocket() {\n        let headers = \"POST /api HTTP/1.1\\r\\nHost: myapp.localhost\\r\\nContent-Type: application/json\\r\\n\\r\\n\";\n        assert!(!is_websocket_upgrade(headers));\n    }\n\n    #[test]\n    fn test_websocket_with_sec_headers() {\n        let headers = \"GET /ws HTTP/1.1\\r\\n\\\n            Host: myapp.localhost\\r\\n\\\n            Upgrade: websocket\\r\\n\\\n            Connection: Upgrade\\r\\n\\\n            Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\\\n            Sec-WebSocket-Version: 13\\r\\n\\r\\n\";\n        assert!(is_websocket_upgrade(headers));\n    }\n}\n\nmod port_availability {\n    use super::*;\n\n    #[test]\n    fn test_port_available_when_free() {\n        let port = get_test_port();\n        let result = TcpListener::bind((\"127.0.0.1\", port));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_port_unavailable_when_bound() {\n        let port = get_test_port();\n        let _listener = TcpListener::bind((\"127.0.0.1\", port)).unwrap();\n\n        let result = TcpListener::bind((\"127.0.0.1\", port));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ipv4_binding() {\n        let port = get_test_port();\n        let result = TcpListener::bind((\"127.0.0.1\", port));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_all_interfaces_binding() {\n        let port = get_test_port();\n        let result = TcpListener::bind((\"0.0.0.0\", port));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_ipv6_binding() {\n        let port = get_test_port();\n        // IPv6 might not be available on all systems\n        let _ = TcpListener::bind((\"::1\", port));\n        // Just verify it doesn't panic\n    }\n}\n\nmod http_responses {\n    #[test]\n    fn test_404_response_format() {\n        let response = \"HTTP/1.1 404 Not Found\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        assert!(response.starts_with(\"HTTP/1.1 404\"));\n        assert!(response.contains(\"Content-Length: 0\"));\n    }\n\n    #[test]\n    fn test_502_response_format() {\n        let error = \"Connection refused\";\n        let response = format!(\"HTTP/1.1 502 Bad Gateway\\r\\nContent-Type: text/plain\\r\\n\\r\\nBad Gateway: {}\", error);\n        assert!(response.starts_with(\"HTTP/1.1 502\"));\n        assert!(response.contains(\"Bad Gateway\"));\n        assert!(response.contains(error));\n    }\n\n    #[test]\n    fn test_200_json_response() {\n        let response = \"HTTP/1.1 200 OK\\r\\nContent-Type: application/json\\r\\n\\r\\n{\\\"ok\\\":true}\";\n        assert!(response.starts_with(\"HTTP/1.1 200\"));\n        assert!(response.contains(\"application/json\"));\n        assert!(response.contains(\"{\\\"ok\\\":true}\"));\n    }\n}\n\nmod dashboard {\n    #[test]\n    fn test_dashboard_html_doctype() {\n        let html = \"<!DOCTYPE html><html>\";\n        assert!(html.starts_with(\"<!DOCTYPE html>\"));\n    }\n\n    #[test]\n    fn test_service_row_html() {\n        let domain = \"api.localhost\";\n        let port = 4000;\n        let url = format!(\"http://{}\", domain);\n\n        let row = format!(\n            r#\"<tr><td>running</td><td>{}</td><td>{}</td></tr>\"#,\n            url, port\n        );\n\n        assert!(row.contains(\"http://api.localhost\"));\n        assert!(row.contains(\"4000\"));\n    }\n\n    #[test]\n    fn test_empty_services_message() {\n        let message = \"No services running. Start one with unport start\";\n        assert!(message.contains(\"No services running\"));\n    }\n}\n\nmod request_routing {\n    #[test]\n    fn test_localhost_dashboard() {\n        let domain = \"localhost\";\n        let show_dashboard = domain == \"localhost\" || domain == \"127.0.0.1\";\n        assert!(show_dashboard);\n    }\n\n    #[test]\n    fn test_127_0_0_1_dashboard() {\n        let domain = \"127.0.0.1\";\n        let show_dashboard = domain == \"localhost\" || domain == \"127.0.0.1\";\n        assert!(show_dashboard);\n    }\n\n    #[test]\n    fn test_service_domain_no_dashboard() {\n        let domain = \"api.localhost\";\n        let show_dashboard = domain == \"localhost\" || domain == \"127.0.0.1\";\n        assert!(!show_dashboard);\n    }\n\n    #[test]\n    fn test_kill_api_path() {\n        let path = \"/api/kill/myapp.localhost\";\n        assert!(path.starts_with(\"/api/kill/\"));\n\n        let target = path.strip_prefix(\"/api/kill/\").unwrap();\n        assert_eq!(target, \"myapp.localhost\");\n    }\n}\n\nmod https_proxy {\n    #[test]\n    fn test_https_port() {\n        let https_port: u16 = 443;\n        assert_eq!(https_port, 443);\n    }\n\n    #[test]\n    fn test_http_port() {\n        let http_port: u16 = 80;\n        assert_eq!(http_port, 80);\n    }\n\n    #[test]\n    fn test_https_url_format() {\n        let domain = \"api.localhost\";\n        let url = format!(\"https://{}\", domain);\n        assert_eq!(url, \"https://api.localhost\");\n    }\n\n    #[test]\n    fn test_http_url_format() {\n        let domain = \"api.localhost\";\n        let url = format!(\"http://{}\", domain);\n        assert_eq!(url, \"http://api.localhost\");\n    }\n\n    #[test]\n    fn test_https_url_with_port() {\n        let domain = \"api.localhost\";\n        let port = 443;\n        let url = format!(\"https://{}:{}\", domain, port);\n        assert_eq!(url, \"https://api.localhost:443\");\n    }\n}\n\nmod edge_cases {\n    use super::*;\n\n    #[test]\n    fn test_empty_host_header() {\n        let headers = \"GET / HTTP/1.1\\r\\nHost:\\r\\n\\r\\n\";\n        let host = extract_host_from_headers(headers);\n        assert_eq!(host, Some(\"\".to_string()));\n    }\n\n    #[test]\n    fn test_host_with_ipv6() {\n        let host = \"[::1]:8080\";\n        let parts: Vec<&str> = host.rsplitn(2, ':').collect();\n        // For IPv6, this naive split doesn't work well\n        // but we test the behavior\n        assert!(parts.len() >= 1);\n    }\n\n    #[test]\n    fn test_very_long_domain() {\n        let long_subdomain = \"a\".repeat(63); // max label length\n        let domain = format!(\"{}.localhost\", long_subdomain);\n        assert!(domain.len() > 63);\n        assert!(domain.ends_with(\".localhost\"));\n    }\n\n    #[test]\n    fn test_domain_with_many_subdomains() {\n        let domain = \"a.b.c.d.e.localhost\";\n        let parts: Vec<&str> = domain.split('.').collect();\n        assert_eq!(parts.len(), 6);\n        assert_eq!(parts.last(), Some(&\"localhost\"));\n    }\n\n    #[test]\n    fn test_punycode_domain() {\n        // Internationalized domain names use punycode\n        let domain = \"xn--n3h.localhost\"; // emoji domain encoded\n        assert!(domain.starts_with(\"xn--\"));\n    }\n\n    #[test]\n    fn test_case_insensitive_domain_matching() {\n        let domain1 = \"API.LOCALHOST\";\n        let domain2 = \"api.localhost\";\n        assert_eq!(domain1.to_lowercase(), domain2.to_lowercase());\n    }\n\n    #[test]\n    fn test_host_header_with_trailing_dot() {\n        // DNS technically allows trailing dots\n        let host = \"api.localhost.\";\n        let normalized = host.trim_end_matches('.');\n        assert_eq!(normalized, \"api.localhost\");\n    }\n\n    #[test]\n    fn test_multiple_colons_in_host() {\n        // IPv6 address has multiple colons\n        let host = \"[2001:db8::1]:8080\";\n        // Our simple split by first colon wouldn't work for IPv6\n        // This tests awareness of the edge case\n        assert!(host.contains(\"::\"));\n    }\n\n    #[test]\n    fn test_kill_api_empty_domain() {\n        let path = \"/api/kill/\";\n        let target = path.strip_prefix(\"/api/kill/\").unwrap_or(\"\");\n        assert_eq!(target, \"\");\n        assert!(target.is_empty());\n    }\n\n    #[test]\n    fn test_kill_api_domain_with_special_chars() {\n        let path = \"/api/kill/my-app_v2.localhost\";\n        let target = path.strip_prefix(\"/api/kill/\").unwrap();\n        assert_eq!(target, \"my-app_v2.localhost\");\n    }\n\n    #[test]\n    fn test_websocket_upgrade_case_variations() {\n        let headers1 = \"Upgrade: WebSocket\";\n        let headers2 = \"upgrade: WEBSOCKET\";\n        let headers3 = \"UPGRADE: websocket\";\n\n        // All should be detected as websocket\n        assert!(headers1.to_lowercase().contains(\"websocket\"));\n        assert!(headers2.to_lowercase().contains(\"websocket\"));\n        assert!(headers3.to_lowercase().contains(\"websocket\"));\n    }\n\n    #[test]\n    fn test_connection_header_variations() {\n        let conn1 = \"Connection: Upgrade\";\n        let conn2 = \"Connection: keep-alive, Upgrade\";\n        let conn3 = \"connection: upgrade\";\n\n        assert!(conn1.to_lowercase().contains(\"upgrade\"));\n        assert!(conn2.to_lowercase().contains(\"upgrade\"));\n        assert!(conn3.to_lowercase().contains(\"upgrade\"));\n    }\n}\n\nmod forwarding {\n    #[test]\n    fn test_backend_address_format() {\n        let port: u16 = 4000;\n        let addr = format!(\"127.0.0.1:{}\", port);\n        assert_eq!(addr, \"127.0.0.1:4000\");\n    }\n\n    #[test]\n    fn test_backend_port_range() {\n        let port: u16 = 4500;\n        assert!(port >= 4000 && port <= 5000);\n    }\n\n    #[test]\n    fn test_x_forwarded_headers() {\n        let original_host = \"api.localhost\";\n        let x_forwarded_host = format!(\"X-Forwarded-Host: {}\", original_host);\n        assert!(x_forwarded_host.contains(\"api.localhost\"));\n    }\n\n    #[test]\n    fn test_x_forwarded_proto_https() {\n        let proto = \"https\";\n        let header = format!(\"X-Forwarded-Proto: {}\", proto);\n        assert!(header.contains(\"https\"));\n    }\n\n    #[test]\n    fn test_x_forwarded_proto_http() {\n        let proto = \"http\";\n        let header = format!(\"X-Forwarded-Proto: {}\", proto);\n        assert!(header.contains(\"http\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","ozan","Projects","unport","tests","registry_tests.rs"],"content":"use std::collections::HashMap;\nuse std::path::PathBuf;\n\nconst PORT_RANGE_START: u16 = 4000;\nconst PORT_RANGE_END: u16 = 5000;\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]\nstruct Service {\n    domain: String,\n    port: u16,\n    pid: u32,\n    directory: PathBuf,\n}\n\n#[derive(Default)]\nstruct Registry {\n    services: HashMap<String, Service>,\n    next_port: u16,\n}\n\nimpl Registry {\n    fn new() -> Self {\n        Self {\n            services: HashMap::new(),\n            next_port: PORT_RANGE_START,\n        }\n    }\n\n    fn get_port(&mut self) -> u16 {\n        let port = self.next_port;\n        self.next_port += 1;\n        if self.next_port > PORT_RANGE_END {\n            self.next_port = PORT_RANGE_START;\n        }\n        port\n    }\n\n    fn register(&mut self, service: Service) {\n        self.services.insert(service.domain.clone(), service);\n    }\n\n    fn unregister(&mut self, domain: &str) -> Option<Service> {\n        self.services.remove(domain)\n    }\n\n    fn get(&self, domain: &str) -> Option<&Service> {\n        self.services.get(domain)\n    }\n\n    fn list(&self) -> Vec<Service> {\n        self.services.values().cloned().collect()\n    }\n}\n\n#[test]\nfn test_registry_new() {\n    let registry = Registry::new();\n    assert!(registry.services.is_empty());\n    assert_eq!(registry.next_port, PORT_RANGE_START);\n}\n\n#[test]\nfn test_get_port_increments() {\n    let mut registry = Registry::new();\n    assert_eq!(registry.get_port(), 4000);\n    assert_eq!(registry.get_port(), 4001);\n    assert_eq!(registry.get_port(), 4002);\n}\n\n#[test]\nfn test_get_port_wraps_around() {\n    let mut registry = Registry::new();\n    registry.next_port = PORT_RANGE_END;\n\n    let port = registry.get_port();\n    assert_eq!(port, PORT_RANGE_END);\n    assert_eq!(registry.next_port, PORT_RANGE_START);\n}\n\n#[test]\nfn test_register_service() {\n    let mut registry = Registry::new();\n    let service = Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 12345,\n        directory: PathBuf::from(\"/home/user/api\"),\n    };\n\n    registry.register(service.clone());\n    assert_eq!(registry.services.len(), 1);\n    assert!(registry.services.contains_key(\"api.localhost\"));\n}\n\n#[test]\nfn test_register_multiple_services() {\n    let mut registry = Registry::new();\n\n    registry.register(Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 1000,\n        directory: PathBuf::from(\"/app/api\"),\n    });\n\n    registry.register(Service {\n        domain: \"web.localhost\".to_string(),\n        port: 4001,\n        pid: 1001,\n        directory: PathBuf::from(\"/app/web\"),\n    });\n\n    assert_eq!(registry.services.len(), 2);\n}\n\n#[test]\nfn test_register_overwrites_existing() {\n    let mut registry = Registry::new();\n\n    registry.register(Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 1000,\n        directory: PathBuf::from(\"/app/api\"),\n    });\n\n    registry.register(Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4001,\n        pid: 1001,\n        directory: PathBuf::from(\"/app/api-new\"),\n    });\n\n    assert_eq!(registry.services.len(), 1);\n    assert_eq!(registry.get(\"api.localhost\").unwrap().port, 4001);\n}\n\n#[test]\nfn test_unregister_service() {\n    let mut registry = Registry::new();\n    let service = Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 12345,\n        directory: PathBuf::from(\"/home/user/api\"),\n    };\n\n    registry.register(service.clone());\n    let removed = registry.unregister(\"api.localhost\");\n\n    assert!(removed.is_some());\n    assert_eq!(removed.unwrap().domain, \"api.localhost\");\n    assert!(registry.services.is_empty());\n}\n\n#[test]\nfn test_unregister_nonexistent() {\n    let mut registry = Registry::new();\n    let removed = registry.unregister(\"nonexistent.localhost\");\n    assert!(removed.is_none());\n}\n\n#[test]\nfn test_get_service() {\n    let mut registry = Registry::new();\n    let service = Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 12345,\n        directory: PathBuf::from(\"/home/user/api\"),\n    };\n\n    registry.register(service);\n\n    let result = registry.get(\"api.localhost\");\n    assert!(result.is_some());\n    assert_eq!(result.unwrap().port, 4000);\n}\n\n#[test]\nfn test_get_nonexistent_service() {\n    let registry = Registry::new();\n    let result = registry.get(\"nonexistent.localhost\");\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_list_empty() {\n    let registry = Registry::new();\n    let list = registry.list();\n    assert!(list.is_empty());\n}\n\n#[test]\nfn test_list_services() {\n    let mut registry = Registry::new();\n\n    registry.register(Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 1000,\n        directory: PathBuf::from(\"/app/api\"),\n    });\n\n    registry.register(Service {\n        domain: \"web.localhost\".to_string(),\n        port: 4001,\n        pid: 1001,\n        directory: PathBuf::from(\"/app/web\"),\n    });\n\n    let list = registry.list();\n    assert_eq!(list.len(), 2);\n}\n\n#[test]\nfn test_service_serialization() {\n    let service = Service {\n        domain: \"api.localhost\".to_string(),\n        port: 4000,\n        pid: 12345,\n        directory: PathBuf::from(\"/home/user/api\"),\n    };\n\n    let json = serde_json::to_string(&service).unwrap();\n    assert!(json.contains(\"api.localhost\"));\n    assert!(json.contains(\"4000\"));\n    assert!(json.contains(\"12345\"));\n}\n\n#[test]\nfn test_service_deserialization() {\n    let json = r#\"{\n        \"domain\": \"api.localhost\",\n        \"port\": 4000,\n        \"pid\": 12345,\n        \"directory\": \"/home/user/api\"\n    }\"#;\n\n    let service: Service = serde_json::from_str(json).unwrap();\n    assert_eq!(service.domain, \"api.localhost\");\n    assert_eq!(service.port, 4000);\n    assert_eq!(service.pid, 12345);\n}\n\n#[test]\nfn test_registry_serialization() {\n    let mut services: HashMap<String, Service> = HashMap::new();\n    services.insert(\n        \"api.localhost\".to_string(),\n        Service {\n            domain: \"api.localhost\".to_string(),\n            port: 4000,\n            pid: 12345,\n            directory: PathBuf::from(\"/home/user/api\"),\n        },\n    );\n\n    let json = serde_json::to_string_pretty(&services).unwrap();\n    let deserialized: HashMap<String, Service> = serde_json::from_str(&json).unwrap();\n\n    assert_eq!(services, deserialized);\n}\n\n#[test]\nfn test_max_port_calculation() {\n    let mut registry = Registry::new();\n\n    registry.register(Service {\n        domain: \"a.localhost\".to_string(),\n        port: 4000,\n        pid: 1,\n        directory: PathBuf::from(\"/a\"),\n    });\n\n    registry.register(Service {\n        domain: \"b.localhost\".to_string(),\n        port: 4005,\n        pid: 2,\n        directory: PathBuf::from(\"/b\"),\n    });\n\n    registry.register(Service {\n        domain: \"c.localhost\".to_string(),\n        port: 4002,\n        pid: 3,\n        directory: PathBuf::from(\"/c\"),\n    });\n\n    let max_port = registry.services.values().map(|s| s.port).max().unwrap();\n    assert_eq!(max_port, 4005);\n}\n\n#[test]\nfn test_port_range_constants() {\n    assert_eq!(PORT_RANGE_START, 4000);\n    assert_eq!(PORT_RANGE_END, 5000);\n    assert!(PORT_RANGE_END > PORT_RANGE_START);\n    assert_eq!(PORT_RANGE_END - PORT_RANGE_START, 1000);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","ozan","Projects","unport","tests","types_tests.rs"],"content":"use std::path::PathBuf;\n\nconst PORT_RANGE_START: u16 = 4000;\nconst PORT_RANGE_END: u16 = 5000;\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]\nstruct Service {\n    domain: String,\n    port: u16,\n    pid: u32,\n    directory: PathBuf,\n}\n\n#[derive(Debug, serde::Serialize, serde::Deserialize, PartialEq)]\nenum Request {\n    Register {\n        domain: String,\n        port: u16,\n        pid: u32,\n        directory: PathBuf,\n    },\n    Unregister {\n        domain: String,\n    },\n    GetPort,\n    List,\n    Stop {\n        domain: String,\n    },\n    Shutdown,\n    HttpsStatus,\n}\n\n#[derive(Debug, serde::Serialize, serde::Deserialize, PartialEq)]\nenum Response {\n    Ok(Option<String>),\n    Port(u16),\n    Services(Vec<Service>),\n    Error(String),\n    HttpsEnabled(bool),\n}\n\nmod service_tests {\n    use super::*;\n\n    #[test]\n    fn test_service_creation() {\n        let service = Service {\n            domain: \"api.localhost\".to_string(),\n            port: 4000,\n            pid: 12345,\n            directory: PathBuf::from(\"/home/user/api\"),\n        };\n\n        assert_eq!(service.domain, \"api.localhost\");\n        assert_eq!(service.port, 4000);\n        assert_eq!(service.pid, 12345);\n        assert_eq!(service.directory, PathBuf::from(\"/home/user/api\"));\n    }\n\n    #[test]\n    fn test_service_clone() {\n        let service = Service {\n            domain: \"api.localhost\".to_string(),\n            port: 4000,\n            pid: 12345,\n            directory: PathBuf::from(\"/home/user/api\"),\n        };\n\n        let cloned = service.clone();\n        assert_eq!(service, cloned);\n    }\n\n    #[test]\n    fn test_service_serialize() {\n        let service = Service {\n            domain: \"api.localhost\".to_string(),\n            port: 4000,\n            pid: 12345,\n            directory: PathBuf::from(\"/home/user/api\"),\n        };\n\n        let json = serde_json::to_string(&service).unwrap();\n        assert!(json.contains(\"api.localhost\"));\n        assert!(json.contains(\"4000\"));\n        assert!(json.contains(\"12345\"));\n    }\n\n    #[test]\n    fn test_service_deserialize() {\n        let json = r#\"{\n            \"domain\": \"api.localhost\",\n            \"port\": 4000,\n            \"pid\": 12345,\n            \"directory\": \"/home/user/api\"\n        }\"#;\n\n        let service: Service = serde_json::from_str(json).unwrap();\n        assert_eq!(service.domain, \"api.localhost\");\n        assert_eq!(service.port, 4000);\n        assert_eq!(service.pid, 12345);\n    }\n\n    #[test]\n    fn test_service_roundtrip() {\n        let service = Service {\n            domain: \"test.localhost\".to_string(),\n            port: 4500,\n            pid: 99999,\n            directory: PathBuf::from(\"/tmp/test\"),\n        };\n\n        let json = serde_json::to_string(&service).unwrap();\n        let deserialized: Service = serde_json::from_str(&json).unwrap();\n        assert_eq!(service, deserialized);\n    }\n}\n\nmod request_tests {\n    use super::*;\n\n    #[test]\n    fn test_register_request() {\n        let req = Request::Register {\n            domain: \"api.localhost\".to_string(),\n            port: 4000,\n            pid: 12345,\n            directory: PathBuf::from(\"/home/user/api\"),\n        };\n\n        let json = serde_json::to_string(&req).unwrap();\n        assert!(json.contains(\"Register\"));\n        assert!(json.contains(\"api.localhost\"));\n    }\n\n    #[test]\n    fn test_unregister_request() {\n        let req = Request::Unregister {\n            domain: \"api.localhost\".to_string(),\n        };\n\n        let json = serde_json::to_string(&req).unwrap();\n        assert!(json.contains(\"Unregister\"));\n        assert!(json.contains(\"api.localhost\"));\n    }\n\n    #[test]\n    fn test_getport_request() {\n        let req = Request::GetPort;\n        let json = serde_json::to_string(&req).unwrap();\n        assert_eq!(json, \"\\\"GetPort\\\"\");\n    }\n\n    #[test]\n    fn test_list_request() {\n        let req = Request::List;\n        let json = serde_json::to_string(&req).unwrap();\n        assert_eq!(json, \"\\\"List\\\"\");\n    }\n\n    #[test]\n    fn test_stop_request() {\n        let req = Request::Stop {\n            domain: \"api.localhost\".to_string(),\n        };\n\n        let json = serde_json::to_string(&req).unwrap();\n        assert!(json.contains(\"Stop\"));\n        assert!(json.contains(\"api.localhost\"));\n    }\n\n    #[test]\n    fn test_shutdown_request() {\n        let req = Request::Shutdown;\n        let json = serde_json::to_string(&req).unwrap();\n        assert_eq!(json, \"\\\"Shutdown\\\"\");\n    }\n\n    #[test]\n    fn test_request_deserialize_register() {\n        let json = r#\"{\"Register\":{\"domain\":\"api.localhost\",\"port\":4000,\"pid\":12345,\"directory\":\"/home/user/api\"}}\"#;\n        let req: Request = serde_json::from_str(json).unwrap();\n\n        match req {\n            Request::Register { domain, port, pid, .. } => {\n                assert_eq!(domain, \"api.localhost\");\n                assert_eq!(port, 4000);\n                assert_eq!(pid, 12345);\n            }\n            _ => panic!(\"Expected Register request\"),\n        }\n    }\n\n    #[test]\n    fn test_https_status_request() {\n        let req = Request::HttpsStatus;\n        let json = serde_json::to_string(&req).unwrap();\n        assert_eq!(json, \"\\\"HttpsStatus\\\"\");\n    }\n\n    #[test]\n    fn test_https_status_request_deserialize() {\n        let json = \"\\\"HttpsStatus\\\"\";\n        let req: Request = serde_json::from_str(json).unwrap();\n        assert_eq!(req, Request::HttpsStatus);\n    }\n}\n\nmod response_tests {\n    use super::*;\n\n    #[test]\n    fn test_ok_response_with_message() {\n        let resp = Response::Ok(Some(\"Success\".to_string()));\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"Ok\"));\n        assert!(json.contains(\"Success\"));\n    }\n\n    #[test]\n    fn test_ok_response_without_message() {\n        let resp = Response::Ok(None);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"Ok\"));\n        assert!(json.contains(\"null\"));\n    }\n\n    #[test]\n    fn test_port_response() {\n        let resp = Response::Port(4000);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"Port\"));\n        assert!(json.contains(\"4000\"));\n    }\n\n    #[test]\n    fn test_services_response_empty() {\n        let resp = Response::Services(vec![]);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"Services\"));\n        assert!(json.contains(\"[]\"));\n    }\n\n    #[test]\n    fn test_services_response_with_items() {\n        let services = vec![\n            Service {\n                domain: \"api.localhost\".to_string(),\n                port: 4000,\n                pid: 1000,\n                directory: PathBuf::from(\"/app/api\"),\n            },\n            Service {\n                domain: \"web.localhost\".to_string(),\n                port: 4001,\n                pid: 1001,\n                directory: PathBuf::from(\"/app/web\"),\n            },\n        ];\n\n        let resp = Response::Services(services);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"api.localhost\"));\n        assert!(json.contains(\"web.localhost\"));\n    }\n\n    #[test]\n    fn test_error_response() {\n        let resp = Response::Error(\"Something went wrong\".to_string());\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"Error\"));\n        assert!(json.contains(\"Something went wrong\"));\n    }\n\n    #[test]\n    fn test_response_roundtrip() {\n        let resp = Response::Port(4500);\n        let json = serde_json::to_string(&resp).unwrap();\n        let deserialized: Response = serde_json::from_str(&json).unwrap();\n        assert_eq!(resp, deserialized);\n    }\n\n    #[test]\n    fn test_https_enabled_response_true() {\n        let resp = Response::HttpsEnabled(true);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"HttpsEnabled\"));\n        assert!(json.contains(\"true\"));\n    }\n\n    #[test]\n    fn test_https_enabled_response_false() {\n        let resp = Response::HttpsEnabled(false);\n        let json = serde_json::to_string(&resp).unwrap();\n        assert!(json.contains(\"HttpsEnabled\"));\n        assert!(json.contains(\"false\"));\n    }\n\n    #[test]\n    fn test_https_enabled_response_deserialize() {\n        let json = r#\"{\"HttpsEnabled\":true}\"#;\n        let resp: Response = serde_json::from_str(json).unwrap();\n        assert_eq!(resp, Response::HttpsEnabled(true));\n\n        let json = r#\"{\"HttpsEnabled\":false}\"#;\n        let resp: Response = serde_json::from_str(json).unwrap();\n        assert_eq!(resp, Response::HttpsEnabled(false));\n    }\n\n    #[test]\n    fn test_https_enabled_response_roundtrip() {\n        let resp = Response::HttpsEnabled(true);\n        let json = serde_json::to_string(&resp).unwrap();\n        let deserialized: Response = serde_json::from_str(&json).unwrap();\n        assert_eq!(resp, deserialized);\n    }\n}\n\nmod port_range_tests {\n    use super::*;\n\n    #[test]\n    fn test_port_range_start() {\n        assert_eq!(PORT_RANGE_START, 4000);\n    }\n\n    #[test]\n    fn test_port_range_end() {\n        assert_eq!(PORT_RANGE_END, 5000);\n    }\n\n    #[test]\n    fn test_port_range_valid() {\n        assert!(PORT_RANGE_END > PORT_RANGE_START);\n    }\n\n    #[test]\n    fn test_port_range_size() {\n        assert_eq!(PORT_RANGE_END - PORT_RANGE_START, 1000);\n    }\n\n    #[test]\n    fn test_port_in_range() {\n        let port = 4500;\n        assert!(port >= PORT_RANGE_START && port <= PORT_RANGE_END);\n    }\n\n    #[test]\n    fn test_port_below_range() {\n        let port = 3000;\n        assert!(port < PORT_RANGE_START);\n    }\n\n    #[test]\n    fn test_port_above_range() {\n        let port = 6000;\n        assert!(port > PORT_RANGE_END);\n    }\n}\n\nmod path_tests {\n    use std::path::PathBuf;\n\n    fn unport_dir() -> PathBuf {\n        dirs::home_dir()\n            .expect(\"Could not find home directory\")\n            .join(\".unport\")\n    }\n\n    fn socket_path() -> PathBuf {\n        unport_dir().join(\"unport.sock\")\n    }\n\n    fn pid_path() -> PathBuf {\n        unport_dir().join(\"unport.pid\")\n    }\n\n    fn registry_path() -> PathBuf {\n        unport_dir().join(\"registry.json\")\n    }\n\n    #[test]\n    fn test_unport_dir() {\n        let dir = unport_dir();\n        assert!(dir.ends_with(\".unport\"));\n    }\n\n    #[test]\n    fn test_socket_path() {\n        let path = socket_path();\n        assert!(path.ends_with(\"unport.sock\"));\n    }\n\n    #[test]\n    fn test_pid_path() {\n        let path = pid_path();\n        assert!(path.ends_with(\"unport.pid\"));\n    }\n\n    #[test]\n    fn test_registry_path() {\n        let path = registry_path();\n        assert!(path.ends_with(\"registry.json\"));\n    }\n\n    #[test]\n    fn test_paths_in_unport_dir() {\n        let dir = unport_dir();\n        let sock = socket_path();\n        let pid = pid_path();\n        let reg = registry_path();\n\n        assert!(sock.starts_with(&dir));\n        assert!(pid.starts_with(&dir));\n        assert!(reg.starts_with(&dir));\n    }\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":3.53356890459364,"covered":30,"coverable":849}